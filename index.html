<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />









  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="FantinOcean">
<meta property="og:url" content="https://fantinyang.github.io/index.html">
<meta property="og:site_name" content="FantinOcean">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FantinOcean">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fantinyang.github.io/"/>





  <title>FantinOcean</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FantinOcean</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Share</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/05/11/post1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/post1/" itemprop="url">To Visiters</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T19:52:05+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> My very first post – To Visiters</p>
<h2 id="Who-Am-I"><a href="#Who-Am-I" class="headerlink" title="Who Am I"></a>Who Am I</h2><p> You can find me in…</p>
<ul>
<li><a href="https://www.facebook.com/profile.php?id=100010334744185" target="_blank" rel="noopener">Facebook</a> </li>
<li><a href="https://twitter.com/yangfantin" target="_blank" rel="noopener">Twitter</a></li>
<li><a href="https://www.instagram.com/yangfantin/" target="_blank" rel="noopener">Instagram</a></li>
<li><a href="https://weibo.com/y526147723/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" target="_blank" rel="noopener">Weibo</a></li>
<li><a href="https://space.bilibili.com/7781422/#/" target="_blank" rel="noopener">Bilibili</a> </li>
<li><a href="yangfan.gm@gmail.com">Email</a>  </li>
</ul>
<p><strong>Facebook</strong>, <strong>Twitter</strong>, <strong>Insta</strong>, and <strong>Weibo</strong> are set up only as my social media, you can follow me if interested, but I won’t guarantee the quality.<br><strong>Bilibili</strong> is where I upload my Vlogs.<br>In the end, don’t hesitate to <strong>Email</strong> me.</p>
<h2 id="What-I-gonna-do"><a href="#What-I-gonna-do" class="headerlink" title="What I gonna do"></a>What I gonna do</h2><p>The reason why I set up this blog is that I want to share my working experience with freshmen in SDN, Wireless Security, OpenWrt and so on. Because when I first stepped foot in these areas, I couldn’t always find the useful information online. There full of repeated tutorials and blogs, and what important is that most of the tutorials are not suitable for freshmen in engineering, because they assume the readers have equipped enough basic knowledge.<br>So I decided to share the journey of me on this blog, where I will focus more on how to start up the engineering and how to get useful information.<br>Hope it will be helpful to you.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2019/07/26/post9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/post9/" itemprop="url">DEMO--Live555取流与ffmpeg解码——从零开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-26T00:12:20+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本片文章主要总结如何利用live555库取流，再使用ffmpeg库将H264解码为YUV420。将这个过程制作为一个demo。因为是第一次涉及视频流传输和解码，所以这种“从零开始”的开发过程可能比较适合新手。<br><a href="http://www.live555.com/" target="_blank" rel="noopener">live555</a>是一个基于RTP/RTSP等协议开源的视频流库。而<a href="https://ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>更像是一个视频处理工具。</p>
<h2 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h2><h3 id="live555部分"><a href="#live555部分" class="headerlink" title="live555部分"></a>live555部分</h3><p>live555的结构还是比较清晰的，如果需要开发一个客户端，主要关注“testProgs”和“testRtspClient”这两个文件夹即可，其中都给出了一些开发实例和源代码。<br>刚开始我以为client就是testRtspClient中的同名.cpp文件，后来发现，在testProgs文件夹中的 testRTSPClient.cpp 才更适合开发。<br>所以我复制了 testRTSPClient.cpp 的代码，放在自己的demo中，把他改名为client.cpp 进行二次开发。</p>
<p>Makefile可以直接参考testRtspClient文件夹中的Makefile，基本是testProgs的缩简版。<br>可以先从Makefile分析一下编译构成。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INCLUDES = -I../UsageEnvironment/<span class="keyword">include</span> -I../groupsock/<span class="keyword">include</span> -I../liveMedia/<span class="keyword">include</span> -I../BasicUsageEnvironment/<span class="keyword">include</span> -I../openRTSP/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">TEST_RTSP_CLIENT_OBJS    = testRtspClient.<span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USAGE_ENVIRONMENT_DIR = ../UsageEnvironment</span><br><span class="line">USAGE_ENVIRONMENT_LIB = <span class="variable">$(USAGE_ENVIRONMENT_DIR)</span>/libUsageEnvironment.<span class="variable">$(libUsageEnvironment_LIB_SUFFIX)</span></span><br><span class="line">BASIC_USAGE_ENVIRONMENT_DIR = ../BasicUsageEnvironment</span><br><span class="line">BASIC_USAGE_ENVIRONMENT_LIB = <span class="variable">$(BASIC_USAGE_ENVIRONMENT_DIR)</span>/libBasicUsageEnvironment.<span class="variable">$(libBasicUsageEnvironment_LIB_SUFFIX)</span></span><br><span class="line">LIVEMEDIA_DIR = ../liveMedia</span><br><span class="line">LIVEMEDIA_LIB = <span class="variable">$(LIVEMEDIA_DIR)</span>/libliveMedia.<span class="variable">$(libliveMedia_LIB_SUFFIX)</span></span><br><span class="line">GROUPSOCK_DIR = ../groupsock</span><br><span class="line">GROUPSOCK_LIB = <span class="variable">$(GROUPSOCK_DIR)</span>/libgroupsock.<span class="variable">$(libgroupsock_LIB_SUFFIX)</span></span><br><span class="line">OPENRTSP_DIR = ../openRTSP</span><br><span class="line">OPENRTSP_LIB = <span class="variable">$(OPENRTSP_DIR)</span>/libRtspClient.<span class="variable">$(libopenrtsp_LIB_SUFFIX)</span></span><br><span class="line">LOCAL_LIBS =	<span class="variable">$(OPENRTSP_LIB)</span> <span class="variable">$(LIVEMEDIA_LIB)</span> <span class="variable">$(GROUPSOCK_LIB)</span> \</span><br><span class="line">        <span class="variable">$(BASIC_USAGE_ENVIRONMENT_LIB)</span> <span class="variable">$(USAGE_ENVIRONMENT_LIB)</span></span><br><span class="line">LIBS =			<span class="variable">$(LOCAL_LIBS)</span> <span class="variable">$(LIBS_FOR_CONSOLE_APPLICATION)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">testRTSPClient$(EXE):	<span class="variable">$(TEST_RTSP_CLIENT_OBJS)</span> <span class="variable">$(LOCAL_LIBS)</span></span></span><br><span class="line">    <span class="variable">$(LINK)</span><span class="variable">$@</span> <span class="variable">$(CONSOLE_LINK_OPTS)</span> <span class="variable">$(TEST_RTSP_CLIENT_OBJS)</span> <span class="variable">$(LIBS)</span> -lpthread</span><br></pre></td></tr></table></figure>
<p>可以看到动态库就是UsageEnvironment，BasicUsageEnvironment，liveMedia，groupsock和openRTSP。所以写demo的时候需要把这几个文件夹中的include和.a文件包含进来。<br>文件结构：<br>.<br>├── BasicUsageEnvironment<br>│   ├── include<br>│   └── libBasicUsageEnvironment.a<br>├── groupsock<br>│   ├── include<br>│   └── libgroupsock.a<br>├── liveMedia<br>│   ├── include<br>│   └── libliveMedia.a<br>├── openRTSP<br>│   ├── include<br>│   └── libRtspClient.a<br>└── UsageEnvironment<br>    ├── include<br>    └── libUsageEnvironment.a</p>
<p>这样就完成了live555的环境配置。</p>
<h3 id="ffmpeg部分"><a href="#ffmpeg部分" class="headerlink" title="ffmpeg部分"></a>ffmpeg部分</h3><p>ffmpeg就没这么简单了，ffmpeg的库很多，互相依赖复杂。因为这个demo中只需要将h264解码为YUV420，所以理论上只需要用到libavformat、libavcodec、libavutil这三个库。但实际上，我最后还加上了libswresample，一共四个库。<br>在网上下好源码包之后，应该先在文件夹下执行<br>        <code>./configure</code><br>        <code>make</code><br>        <code>make install</code><br>确保几个库中都编译好动态库，方便直接拷贝引用。<br>我的方式是直接复制上诉4个文件夹在demo文件夹中，文件夹除了包含头文件还应该包含动态库。</p>
<h3 id="Makefile修改"><a href="#Makefile修改" class="headerlink" title="Makefile修改"></a>Makefile修改</h3><p>整个demo的文件结构是这样的：<br>.<br>├── libavcodec<br>├── libavformat<br>├── libavutil<br>├── libswresample<br>├── live<br>├── client.cpp</p>
<p>live中是上述live555的库，client.cpp 是主函数。</p>
<p>因为ffmepg的头文件引用都是使用 <code>#include &lt;libavcodec/avcodec.h&gt;</code>这样的方式引用，所以我把主函数和几个库文件夹放在同一个根目录下。<br>live555通过<code>#include &quot;liveMedia.hh&quot;</code>引用。所以live555需要分别添加库的文件地址，而ffmpeg只需要添加根地址。</p>
<p>Makefile在上述testRTSPClient的Makefile中修改。</p>
<ol>
<li>INCLUDES 中添加ffmpeg几个库的根地址。<br>   这里的根地址就是当前地址。<br>   在原来的INCLUDES 后面添加  <code>-I./</code> 即可。</li>
<li>live库的引用则需要在原来的基础上加上live/。需要注意的是，还是因为目录结构的不同，原版Makefile的INCLUDES 后面有两个.. ，在我的目录结构下，只需要一个。大家要根据自己的结构修改。</li>
<li>最终版本：<br>  <code>INCLUDES = -I./live/UsageEnvironment/include -I./live/groupsock/include -I./live/liveMedia/include -I./live/BasicUsageEnvironment/include -I./live/openRTSP/include -I./</code></li>
</ol>
<p>除了-I的修改，还有链接库需要修改。<br>我按照live555的写法，把ffmpeg的链接库添加在后面，具体是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIBAVCODEC_DIR = ./libavcodec</span><br><span class="line">LIBAVCODEC_LIB = <span class="variable">$(LIBAVCODEC_DIR)</span>/libavcodec.<span class="variable">$(LIB_SUFFIX)</span></span><br><span class="line">LIBAVUTIL_DIR = ./libavutil</span><br><span class="line">LIBAVUTIL_LIB = <span class="variable">$(LIBAVUTIL_DIR)</span>/libavutil.<span class="variable">$(LIB_SUFFIX)</span></span><br><span class="line">LIBAVFORMAT_DIR = ./libavformat</span><br><span class="line">LIBAVFORMAT_LIB = <span class="variable">$(LIBAVFORMAT_DIR)</span>/libavformat.<span class="variable">$(LIB_SUFFIX)</span></span><br><span class="line">LIBSWRESAMPLE_DIR = ./libswresample</span><br><span class="line">LIBSWRESAMPLE_LIB = <span class="variable">$(LIBSWRESAMPLE_DIR)</span>/libswresample.<span class="variable">$(LIB_SUFFIX)</span></span><br><span class="line"></span><br><span class="line">LOCAL_LIBS =	<span class="variable">$(OPENRTSP_LIB)</span> <span class="variable">$(LIVEMEDIA_LIB)</span> <span class="variable">$(GROUPSOCK_LIB)</span> \</span><br><span class="line">        <span class="variable">$(BASIC_USAGE_ENVIRONMENT_LIB)</span> <span class="variable">$(USAGE_ENVIRONMENT_LIB)</span>\</span><br><span class="line">        <span class="variable">$(LIBAVCODEC_LIB)</span> <span class="variable">$(LIBAVFORMAT_LIB)</span> <span class="variable">$(LIBAVUTIL_LIB)</span> <span class="variable">$(LIBSWRESAMPLE_LIB)</span></span><br></pre></td></tr></table></figure></p>
<p>基本就是加上lib地址，然后在local_libs里面添加就可以。</p>
<p>这样，demo的环境就搭好了，可以修改代码，然后make编译。</p>
<h2 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h2><h3 id="live555解读"><a href="#live555解读" class="headerlink" title="live555解读"></a>live555解读</h3><p>live555的代码读起来真的是新手不友好，但是修改起来还是方便的。<br>找到main函数，首先初始化环境env<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TaskScheduler* scheduler = BasicTaskScheduler::createNew();</span><br><span class="line">UsageEnvironment* env = BasicUsageEnvironment::createNew(*scheduler);</span><br></pre></td></tr></table></figure></p>
<p>调用OpenUrl函数打开url（rtsp://摄像头的ip, 而且url是支持用户名密码认证的：rtsp://admin:password@ip）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= argc<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">openURL(*env, argv[<span class="number">0</span>], argv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就开始循环执行env下的task。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;taskScheduler().doEventLoop(&amp;eventLoopWatchVariable);</span><br></pre></td></tr></table></figure></p>
<p>task包括什么，基本就是所有调用了<code>UsageEnvironment* env</code>的函数。<br>因为我们的目的是通过live收到一帧视频并解码，所以可以不关注连接建立的过程，主要关注收到视频帧部分的操作。</p>
<p>这里有一个类比较重要：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DummySink* <span class="title">createNew</span><span class="params">(UsageEnvironment&amp; env,</span></span></span><br><span class="line"><span class="function"><span class="params">                MediaSubsession&amp; subsession, <span class="comment">// identifies the kind of data that's being received</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> <span class="keyword">const</span>* streamId = <span class="literal">NULL</span>)</span></span>; <span class="comment">// identifies the stream itself (optional)</span></span><br></pre></td></tr></table></figure></p>
<p>他相当于提供一个池子，接受视频帧。子函数包括：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DummySink* DummySink::createNew(UsageEnvironment&amp; env, MediaSubsession&amp; subsession, <span class="keyword">char</span> <span class="keyword">const</span>* streamId) </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DummySink::afterGettingFrame(<span class="keyword">void</span>* clientData, <span class="keyword">unsigned</span> frameSize, <span class="keyword">unsigned</span> numTruncatedBytes,</span><br><span class="line">                struct timeval presentationTime, <span class="keyword">unsigned</span> durationInMicroseconds)</span><br><span class="line"></span><br><span class="line">Boolean DummySink::continuePlaying()</span><br></pre></td></tr></table></figure></p>
<p>分别是构造——处理——继续的过程。</p>
<p>如果我们需要对视频帧处理，直接将处理函数加在<code>afterGettingFrame</code>函数末尾，<code>continuePlaying()</code>前面即可。</p>
<h3 id="H264-与-sps-pps帧"><a href="#H264-与-sps-pps帧" class="headerlink" title="H264 与 sps pps帧"></a>H264 与 sps pps帧</h3><p>live555接受到的是H264的裸流，要获取h264格式，需要在原始数据的高为加包头。而原始数据保存在DummySink的成员函数fReceiveBuffer中，大小保存在freamesize里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *SaveData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[DUMMY_SINK_RECEIVE_BUFFER_SIZE + <span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> head[<span class="number">4</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(SaveData, head, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(SaveData+<span class="number">4</span>, fReceiveBuffer,frameSize);</span><br></pre></td></tr></table></figure>
<p>DUMMY_SINK_RECEIVE_BUFFER_SIZE根据摄像头数据定义，可以定义大一些。</p>
<p><code>#define DUMMY_SINK_RECEIVE_BUFFER_SIZE 409600</code></p>
<p>解码为YUV420需要依赖sps和pps帧，在live中，这两帧分别以数组形式保存在SPropRecord中，通过下面的代码将他们取出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SPropRecords = <span class="number">-1</span>;</span><br><span class="line">SPropRecord *p_record = parseSPropParameterSets(fSubsession.fmtp_spropparametersets(), SPropRecords);</span><br><span class="line">    <span class="comment">//sps pps 以数组的形式保存SPropRecord中</span></span><br><span class="line">SPropRecord &amp;sps = p_record[<span class="number">0</span>];</span><br><span class="line">SPropRecord &amp;pps = p_record[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这样，我们就获得了h264包和sps pps帧数据。</p>
<h3 id="ffmpeg调用"><a href="#ffmpeg调用" class="headerlink" title="ffmpeg调用"></a>ffmpeg调用</h3><p>我将解码部分代码写在decodeyuv()函数中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decoderyuv</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * inbuf, <span class="keyword">int</span> read_size, SPropRecord &amp;sps, SPropRecord &amp;pps)</span></span></span><br><span class="line"><span class="function"></span>&#123;   &#125;</span><br></pre></td></tr></table></figure>
<p>h264包、包大小、sps和pps帧作为函数输入。</p>
<p>首先，需要对解码器初始化。但是考虑到解码过程中是收到一帧解码一帧，但对解码器的初始化只需要做一次，否则会丢失sps和pps帧和其他环境变量的依赖。</p>
<p><strong>所以，我将以下初始化代码放在主函数中，将变量作为全局变量声明。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *codec;</span><br><span class="line">AVCodecContext *c = <span class="literal">NULL</span>;</span><br><span class="line">AVFrame *frame;</span><br><span class="line">AVCodecParserContext *avParserContext;</span><br><span class="line"></span><br><span class="line">avcodec_register_all();</span><br><span class="line">codec = avcodec_find_decoder(AV_CODEC_ID_H264);</span><br><span class="line"><span class="keyword">if</span>( <span class="literal">NULL</span> == codec )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Codec not found\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = avcodec_alloc_context3(codec);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avParserContext = av_parser_init(AV_CODEC_ID_H264);</span><br><span class="line"><span class="keyword">if</span>( <span class="literal">NULL</span> == avParserContext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Could not init avParserContext\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(avcodec_open2(c,codec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Could not open codec\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame = av_frame_alloc();</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == frame)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Could not allocate video frame\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是decodeyuv函数代码。</p>
<ul>
<li>首先将sps和pps帧添加到context的 extradata中。</li>
<li>然后将extradata（sps 和pps帧数据）添加到h264数据前，重构buffer。</li>
<li>使用解码器解码，解码后的数据将存储在frame-&gt;data中，而got_frame变量记录了解码数据大小。</li>
<li>将解码后的YUV数据存储到文件。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decoderyuv</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * inbuf, <span class="keyword">int</span> read_size, SPropRecord &amp;sps, SPropRecord &amp;pps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> got_frame;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;extradata == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> totalsize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* tmp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> nalu_header[<span class="number">4</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line">        totalsize = <span class="number">8</span> + sps.sPropLength + pps.sPropLength;</span><br><span class="line">        <span class="comment">//在每个sps 和pps 之前加上startcode </span></span><br><span class="line">        tmp = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">realloc</span>(tmp, totalsize);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, nalu_header, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp + <span class="number">4</span>, sps.sPropBytes, sps.sPropLength);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp + <span class="number">4</span> + sps.sPropLength, nalu_header, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp + <span class="number">4</span> + sps.sPropLength + <span class="number">4</span>, pps.sPropBytes, pps.sPropLength);</span><br><span class="line">        <span class="comment">//printf("sps len:%d, pps len:%d\n", sps.sPropLength, pps.sPropLength);</span></span><br><span class="line">        <span class="comment">//将 sps 和pps 的数据给ffmpeg的h264解码器上下文</span></span><br><span class="line">        c-&gt;extradata_size = totalsize;</span><br><span class="line">        c-&gt;extradata = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重构buf</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> * poutbuf = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(INBUF_SIZE*<span class="number">2</span> + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">    <span class="keyword">int</span> buf_size = read_size + c-&gt;extradata_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(poutbuf, c-&gt;extradata, c-&gt;extradata_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(poutbuf + c-&gt;extradata_size, inbuf, read_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解码器解码</span></span><br><span class="line">    AVPacket avpkt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    av_init_packet(&amp;avpkt);</span><br><span class="line">    avpkt.data = poutbuf;</span><br><span class="line">    avpkt.size = read_size + c-&gt;extradata_size;</span><br><span class="line">    <span class="keyword">time_t</span> start ,end;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">int</span> decode_len = avcodec_decode_video2(c,frame, &amp;got_frame, &amp;avpkt);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"decoded frame used %d\n"</span>,end - start);</span><br><span class="line">    <span class="keyword">if</span>(decode_len &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error while decoding frame \n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(got_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> width = frame-&gt;width;</span><br><span class="line">        <span class="keyword">int</span> height = frame-&gt;height;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"decode success\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"width:%d, height:%d\n"</span>, frame-&gt;width, frame-&gt;height);</span><br><span class="line">        <span class="keyword">if</span>( savefile)</span><br><span class="line">        &#123;</span><br><span class="line">        yuv_fp = fopen(filename, <span class="string">"a+b"</span>);</span><br><span class="line">        解码后，存储的文件</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == yuv_fp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Open file failed\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* yuv_buf = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(width * height *<span class="number">1.5</span>);<span class="comment">//可以放在while循环外面，这样就不用每次都申请，释放了</span></span><br><span class="line">        <span class="comment">//unsigned char* outbuff = (unsigned char*)malloc(width * height *1.5);</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把解码出来的数据存成YUV数据，方便验证解码是否正确</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; height; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(yuv_buf + width * i, frame-&gt;data[<span class="number">0</span>] + frame-&gt;linesize[<span class="number">0</span>]*i, width);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; height &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(yuv_buf + width * height + width *i / <span class="number">2</span>, frame-&gt;data[<span class="number">1</span>] + frame-&gt;linesize[<span class="number">1</span>]*i, width / <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">memcpy</span>(yuv_buf + width * height * <span class="number">5</span> /<span class="number">4</span> + width * i / <span class="number">2</span> ,frame-&gt;data[<span class="number">2</span>] + frame-&gt;linesize[<span class="number">2</span>]*i, width / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fwrite(yuv_buf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>),width * height * <span class="number">1.5</span> ,yuv_fp);</span><br><span class="line">        <span class="built_in">free</span>(yuv_buf);</span><br><span class="line">        fclose(yuv_fp);</span><br><span class="line">        yuv_fp = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(poutbuf);</span><br><span class="line">    <span class="comment">//记得释放变量的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，就可以完成一个从live555取流，用ffmpeg解码为YUV，再将视频存储的demo。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2019/06/21/post8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/post8/" itemprop="url">基于CoAP的AP无线网络数据传输设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-21T11:15:13+08:00">
                2019-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇内容是关于AP的改造设计，该设计可分为AP网络扫描功能设计和AP数据传输设计。即AP扫描网络环境数据包，同时将网络数据通过CoAP协议上传。由此，AP可作为网络安全代理起，实时监控无线网络环境数据。</p>
<p>功能模块：</p>
<ol>
<li><p>网络扫描功能</p>
</li>
<li><p>基于CoAP协议传输功能</p>
</li>
</ol>
<h2 id="AP网络环境扫描实现"><a href="#AP网络环境扫描实现" class="headerlink" title="AP网络环境扫描实现"></a>AP网络环境扫描实现</h2><h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><p>该功能模块参考AP开源应用iwcap，packet可在OpenWrt wiki上<a href="https://openwrt.org/packages/pkgdata/iwcap" target="_blank" rel="noopener">查询</a>, github<a href="https://github.com/openwrt/openwrt/tree/master/package/network/utils/iwcap" target="_blank" rel="noopener">源代码</a>。</p>
<p>其核心实现是通过绑定本地无线网卡，建立socket通信通道，完成无线数据包抓取。</p>
<p>具体实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">capture_sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); #简历socket通道</span><br><span class="line">bind(capture_sock, (struct sockaddr *)&amp;local, sizeof(local)); # 绑定网卡与通道</span><br><span class="line">pktlen = recvfrom(capture_sock, pktbuf, sizeof(pktbuf), 0, NULL, 0); #从通道抓包</span><br></pre></td></tr></table></figure>
<h3 id="socket通信"><a href="#socket通信" class="headerlink" title="socket通信"></a>socket通信</h3><p> 在Unix/Linux系统中，为了统一对各硬件的操作，简化接口，不同硬件设备可以被看成一个文件，等同于对磁盘上普通文件的操作。</p>
<p>用socket()函数创建一个网络连接，其返回值就是文件描述符。根据文件描述符，我们可以使用普通的文件操作来传输数据。</p>
<p>相关函数：accept, bind, connect, listen…</p>
<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数domain指定使用何种地址类型，常见的包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PF_UNIX/PF_LOCAL/AF_UNIX/AF_LOCAL UNIX #进程通信协议</span><br><span class="line">PF_INET?AF_INET Ipv4 #网络协议</span><br><span class="line">PF_INET6/AF_INET6 Ipv6 #网络协议</span><br><span class="line">PF_IPX/AF_IPX IPX-Novell #协议</span><br><span class="line">PF_NETLINK/AF_NETLINK #核心用户接口装置</span><br><span class="line">PF_X25/AF_X25 #ITU-T X<span class="number">.25</span>/ISO<span class="number">-8208</span> 协议</span><br><span class="line">PF_AX25/AF_AX25 #业余无线AX. <span class="number">25</span> 协议</span><br><span class="line">PF_ATMPVC/AF_ATMPVC #存取原始 ATM PVCs</span><br><span class="line">PF_APPLETALK/AF_APPLETALK <span class="meta">#appletalk (DDP)协议</span></span><br><span class="line">PF_PACKET/AF_PACKET #初级封包接口</span><br></pre></td></tr></table></figure>
<p>参数type：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM #提供双向连续且可信赖的数据流, 即TCP. 支持 OOB 机制, 在所有数据传送前必须使用connect()来建立连线状态.</span><br><span class="line">SOCK_DGRAM #使用不连续不可信赖的数据包连接</span><br><span class="line">SOCK_SEQPACKET #提供连续可信赖的数据包连接</span><br><span class="line">SOCK_RAW #提供原始网络协议存取</span><br><span class="line">SOCK_RDM #提供可信赖的数据包连接</span><br><span class="line">SOCK_PACKET #提供和网络驱动程序直接通信. protocol 用来指定socket 所使用的传输协议编号, 通常此参考不用管它, 设为<span class="number">0</span> 即可.</span><br></pre></td></tr></table></figure>
<p>在此应用中，协议指定从数据链路中接收分组。ETH_P_ALL定义于 /usr/include/linux/if_ether.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_ALL 0x0003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_LOOP      0x0060          <span class="comment">/* Ethernet Loopback packet     */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_PUP       0x0200          <span class="comment">/* Xerox PUP packet             */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_PUPAT     0x0201          <span class="comment">/* Xerox PUP Addr Trans packet  */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_IP        0x0800          <span class="comment">/* Internet Protocol packet     */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_X25       0x0805          <span class="comment">/* CCITT X.25                   */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_ARP       0x0806          <span class="comment">/* Address Resolution packet    */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_BPQ       0x08FF          <span class="comment">/* G8BPQ AX.25 Ethernet Packet  [ NOT AN</span></span></span><br><span class="line"><span class="meta"><span class="comment">#define ETH_P_IEEEPUP   0x0a00          /* Xerox IEEE802.3 PUP packet */</span>        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_IEEEPUPAT 0x0a01          <span class="comment">/* Xerox IEEE802.3 PUP Addr Trans packe[t*/</span></span></span><br></pre></td></tr></table></figure>
<p><a href="[http://c.biancheng.net/cpp/html/376.html](http://c.biancheng.net/cpp/html/376.html">参考链接1</a>)</p>
<p><a href="https://blog.csdn.net/baidu20008/article/details/10225073" target="_blank" rel="noopener">参考链接2</a></p>
<h2 id="CoAP客户端-服务器在AP上的C语言实现"><a href="#CoAP客户端-服务器在AP上的C语言实现" class="headerlink" title="CoAP客户端/服务器在AP上的C语言实现"></a>CoAP客户端/服务器在AP上的C语言实现</h2><p>协议参考<a href="https://tools.ietf.org/html/rfc7252" target="_blank" rel="noopener">RFC7252</a></p>
<p>CoAP以各种语言的具体实现均有版本，如有需要可以在<a href="https://my.oschina.net/RainyZou/blog/1605334" target="_blank" rel="noopener">此博客</a>查看。</p>
<p>我在实现上参考了<a href="https://github.com/1248/microcoap" target="_blank" rel="noopener">microcoap</a>中的coap.c, coap.h 和 endpoint.h。</p>
<h3 id="传输方案设计"><a href="#传输方案设计" class="headerlink" title="传输方案设计"></a>传输方案设计</h3><p>将CoAP客户端部署在AP上，CoAP服务器部署在云平台。</p>
<p>CoAP client 主动向 Server发送CON消息，完成认证和连接。Server向Client发送ACK消息，消息option中存放”start” / “stop” 控制程序开始 / 结束。</p>
<p>程序开始，AP抓取网络数据包，数据内容存放在CoAP数据包 payload中，并以NON类型上传至Server。具体传输过程如图：</p>
<p>接下来简单介绍客户端和服务器代码实现的核心内容。</p>
<h3 id="CoAP包结构"><a href="#CoAP包结构" class="headerlink" title="CoAP包结构"></a>CoAP包结构</h3><p>microcoap代码中的核心函数主要包括：coap_build、coap_parse、coap_handle_req 分别执行数据包构建、数据包解析和数据包回复的功能。熟悉CoAP协议的包结构后理解比较简单，下面主要介绍一下CoAP协议的包结构。</p>
<p><img src="coap1.png" alt=""></p>
<p>【Ver】 版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。</p>
<p>【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。</p>
<p>【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID（报文编号），一种为Token（标识符）。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。</p>
<p>【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。</p>
<p>【Message ID】报文编号</p>
<p>【Token】标识符具体内容，通过TKL指定Token长度。</p>
<p>【Option】报文选项，通过报文选项可设定CoAP主机，CoAP URI，CoAP请求参数和负载媒体类型等等。</p>
<p>【1111 1111B】CoAP报文和具体负载之间的分隔符。</p>
<h4 id="Code部分"><a href="#Code部分" class="headerlink" title="Code部分"></a>Code部分</h4><p>Code部分被分成了两部分，为了便于阅读，Code被描述为c.dd形式。具体内容可参考RFC7252 #12.1.1 Method Codes</p>
<h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><p>​    在CoAP请求中，Code被定义为CoAP请求方法，这些方法有GET、POST、PUT和DELETE，这些方法和HTTP协议非常相似。</p>
<p>​    （0.01）GET方法——用于获得某资源</p>
<p>​    （0.02）POST方法——用于创建某资源</p>
<p>​    （0.03）PUT方法——用于更新某资源</p>
<p>​    （0.04）DELETE方法——用于删除某资源</p>
<h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><p>​    在CoAP响应中，Code被定义为CoAP响应码，类似于HTTP 200 OK等等。</p>
<p>​    （2.01）Created</p>
<p>​    （2.02）Deleted</p>
<p>​    （2.03）Valid</p>
<p>​    （2.04）Changed</p>
<p>​    （2.05）Content。类似于HTTP 200 OK</p>
<p>​    </p>
<p>​    （4.00）Bad Request 请求错误，服务器无法处理。类似于HTTP 400。</p>
<p>​    （4.01）Unauthorized 没有范围权限。类似于HTTP 401。</p>
<p>​    （4.02）Bad Option 请求中包含错误选项。</p>
<p>​    （4.03）Forbidden 服务器拒绝请求。类似于HTTP 403。</p>
<p>​    （4.04）Not Found 服务器找不到资源。类似于HTTP 404。</p>
<p>​    （4.05）Method Not Allowed 非法请求方法。类似于HTTP 405。</p>
<p>​    （4.06）Not Acceptable 请求选项和服务器生成内容选项不一致。类似于HTTP 406。</p>
<p>​    （4.12）Precondition Failed 请求参数不足。类似于HTTP 412。</p>
<p>​    （4.15）Unsuppor Conten-Type 请求中的媒体类型不被支持。类似于HTTP 415。</p>
<p>​    （5.00）Internal Server Error 服务器内部错误。类似于HTTP 500。</p>
<p>​    （5.01）Not Implemented 服务器无法支持请求内容。类似于HTTP 501。</p>
<p>​    （5.02）Bad Gateway 服务器作为网关时，收到了一个错误的响应。类似于HTTP 502。</p>
<p>​    （5.03）Service Unavailable 服务器过载或者维护停机。类似于HTTP 503。</p>
<p>​    （5.04）Gateway Timeout 服务器作为网关时，执行请求时发生超时错误。类似于HTTP 504。</p>
<p>​    （5.05）Proxying Not Supported 服务器不支持代理功能。</p>
<p>在程序中，code占8位，具体编程实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_RSPCODE(clas, det)((clas &lt;&lt; 5) | det)</span></span><br><span class="line"></span><br><span class="line">COAP_RSPCODE_CONTENT = MAKE_RSPCODE(<span class="number">2</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Option部分"><a href="#Option部分" class="headerlink" title="Option部分"></a>Option部分</h4><p>CoAP支持多个Option，CoAP的Option的表示方法比较特殊，采用增量的方式描述，细节可参考RFC7252 #3.1</p>
<p><img src="option1.png" alt="option1"></p>
<p> 一般情况下Option部分包含Option Delta、Option Length和Option Value三部分。</p>
<p>​    【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。</p>
<p>​    【Option Length】表示Option Value的具体长度。</p>
<p>​    【Option Value】表示Option具体内容</p>
<p>​    CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。</p>
<p><img src="option2.png" alt="option2"></p>
<p> 在这些option中，Uri-Host、Uri-Port、Uri-Path和Uri-Query等和资源“位置”和参数有关。</p>
<p>​    【3】Uri-Host:CoAP主机名称，例如iot.eclipse.org</p>
<p>​    【7】Uri-Port:CoAP端口号，默认为5683</p>
<p>​    【11】Uri-Path:资源路由或路径，例如\temperature。资源路径采用UTF8字符串形式，长度不计第一个”\”。</p>
<p>​    【15】Uri-Query:访问资源参数，例如?value1=1&amp;value2=2，参数与参数之间使用“&amp;”分隔，Uri-Query和Uri-Path之间采用“?”分隔。</p>
<p>​    在这些option中，Content-Format和Accept用于表示CoAP负载的媒体格式</p>
<p>​    【12】Content-Format:指定CoAP复杂媒体类型，媒体类型采用整数描述，例如application/json对应整数50，application/octet-stream对应整数40。</p>
<p>​    【17】Accept: 指定CoAP响应复杂中的媒体类型，媒体类型的定义和Content-Format相同。</p>
<p>​    CoAP协议中支持多个Option，例如</p>
<p>​    第一个Option Delta=11，表示该Option表示Uri-Path(11)</p>
<p>​    第二个Option Delta=1，表示该Option=1+11，表示Content-Format(12)</p>
<p>​    第三个Option Delta=3，表示该Option=3+1+11，表示Uri-Query(15)</p>
<p>​    CoAP采用这样的方式表示多个Option，而每种Option都可以在HTTP协议中找到对应项。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/07/24/post7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/24/post7/" itemprop="url">OpenFlow1.0.0 代码解读——add port</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-24T14:57:26+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文章解析主函数中没有详细解读的 add_ports 函数。</p>
<p>主函数引用调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (port_list) &#123;</span><br><span class="line">    add_ports(dp, port_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数开始时，将 <strong>port_list</strong> 里的端口打开。</p>
<h2 id="add-port"><a href="#add-port" class="headerlink" title="add_port"></a>add_port</h2><p><a href="https://blog.csdn.net/xhu_eternalcc/article/details/19770467" target="_blank" rel="noopener"><strong>strtok_r</strong></a> 函数相当于是 linux 平台下的 <strong>strtok</strong> 函数，主要用于分隔结构体的各成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">add_ports(struct datapath *dp, <span class="keyword">char</span> *port_list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *port, *save_ptr; </span><br><span class="line">    <span class="comment">/* Glibc 2.7 has a bug in strtok_r when compiling with optimization that</span></span><br><span class="line"><span class="comment">     * can cause segfaults here:</span></span><br><span class="line"><span class="comment">     * http://sources.redhat.com/bugzilla/show_bug.cgi?id=5614.</span></span><br><span class="line"><span class="comment">     * Using ",," instead of the obvious "," works around it. */</span></span><br><span class="line">    <span class="keyword">for</span> (port = strtok_r(port_list, <span class="string">",,"</span>, &amp;save_ptr); port;</span><br><span class="line">         port = strtok_r(<span class="literal">NULL</span>, <span class="string">",,"</span>, &amp;save_ptr)) &#123;</span><br><span class="line">        <span class="keyword">int</span> error = dp_add_port(dp, port, num_queues);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            ofp_fatal(error, <span class="string">"failed to add port %s"</span>, port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数首先对 port_list 结构体做处理，赋值到参数 port 中，port 作为具体的端口名，调用 <strong>dp_add_port</strong> 函数。</p>
<h2 id="dp-add-port"><a href="#dp-add-port" class="headerlink" title="dp_add_port"></a>dp_add_port</h2><p>此函数中的 port 与上一层函数的 port 不同，add_port 中的 port 是一个 char 型指针变量，指向端口名。这一函数中的 port 是 <strong>sw_port</strong> 结构体的指针，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_port</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> config;            <span class="comment">/* Some subset of OFPPC_* flags. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> state;             <span class="comment">/* Some subset of OFPPS_* flags. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">datapath</span> *<span class="title">dp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev</span> *<span class="title">netdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">node</span>;</span> <span class="comment">/* Element in datapath.ports. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> rx_packets, tx_packets;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> rx_bytes, tx_bytes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> tx_dropped;</span><br><span class="line">    <span class="keyword">uint16_t</span> port_no;</span><br><span class="line">    <span class="comment">/* port queues */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> num_queues;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_queue</span> <span class="title">queues</span>[<span class="title">NETDEV_MAX_QUEUES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">queue_list</span>;</span> <span class="comment">/* list of all queues for this port */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sw_port 结构体中包含具体的网络端口 <strong>netdev</strong> ，所以函数判断 port 结构体中的 netdev 是否为空，从而判断端口是否打开。没有打开则调用 <strong>new_port</strong> 函数打开端口。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">dp_add_port(struct datapath *dp, <span class="keyword">const</span> <span class="keyword">char</span> *netdev, <span class="keyword">uint16_t</span> num_queues)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> port_no;</span><br><span class="line">    <span class="keyword">for</span> (port_no = <span class="number">1</span>; port_no &lt; DP_MAX_PORTS; port_no++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_port</span> *<span class="title">port</span> = &amp;<span class="title">dp</span>-&gt;<span class="title">ports</span>[<span class="title">port_no</span>];</span></span><br><span class="line">        <span class="keyword">if</span> (!port-&gt;netdev) &#123;</span><br><span class="line">            <span class="keyword">return</span> new_port(dp, port, port_no, netdev, <span class="literal">NULL</span>, num_queues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXFULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="new-port"><a href="#new-port" class="headerlink" title="new_port"></a>new_port</h2><p>该函数的主要功能包括：</p>
<ul>
<li>调用 <strong>netdev_open</strong> 函数打开网络设备，成功则返回0。具体的网络设备处理由 <strong>do_open_netdev</strong> 执行。</li>
<li>设置网络设备的mac地址</li>
<li>设置flags</li>
<li>设置ip地址</li>
<li>添加信息到 port 结构体中</li>
<li>调用 <strong>send_port_status</strong>  将端口设置成功的消息发送到与controller之间的安全信道</li>
</ul>
<p>函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">new_port(struct datapath *dp, struct sw_port *port, <span class="keyword">uint16_t</span> port_no,</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">char</span> *netdev_name, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *new_mac, <span class="keyword">uint16_t</span> num_queues)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev</span> *<span class="title">netdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">in6</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in4</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = netdev_open(netdev_name, NETDEV_ETH_TYPE_ANY, &amp;netdev);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (new_mac &amp;&amp; !eth_addr_equals(netdev_get_etheraddr(netdev), new_mac)) &#123;</span><br><span class="line">        <span class="comment">/* Generally the device has to be down before we change its hardware</span></span><br><span class="line"><span class="comment">         * address.  Don't bother to check for an error because it's really</span></span><br><span class="line"><span class="comment">         * the netdev_set_etheraddr() call below that we care about. */</span></span><br><span class="line">        netdev_set_flags(netdev, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        error = netdev_set_etheraddr(netdev, new_mac);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            VLOG_WARN(<span class="string">"failed to change %s Ethernet address "</span></span><br><span class="line">                      <span class="string">"to "</span>ETH_ADDR_FMT<span class="string">": %s"</span>,</span><br><span class="line">                      netdev_name, ETH_ADDR_ARGS(new_mac), strerror(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    error = netdev_set_flags(netdev, NETDEV_UP | NETDEV_PROMISC, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"failed to set promiscuous mode on %s device"</span>, netdev_name);</span><br><span class="line">        netdev_close(netdev);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (netdev_get_in4(netdev, &amp;in4)) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"%s device has assigned IP address %s"</span>,</span><br><span class="line">                 netdev_name, inet_ntoa(in4));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (netdev_get_in6(netdev, &amp;in6)) &#123;</span><br><span class="line">        <span class="keyword">char</span> in6_name[INET6_ADDRSTRLEN + <span class="number">1</span>];</span><br><span class="line">        inet_ntop(AF_INET6, &amp;in6, in6_name, <span class="keyword">sizeof</span> in6_name);</span><br><span class="line">        VLOG_ERR(<span class="string">"%s device has assigned IPv6 address %s"</span>,</span><br><span class="line">                 netdev_name, in6_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_queues &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        error = netdev_setup_slicing(netdev, num_queues);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            VLOG_ERR(<span class="string">"failed to configure slicing on %s device: "</span>\</span><br><span class="line">                     <span class="string">"check INSTALL for dependencies, or rerun "</span>\</span><br><span class="line">                     <span class="string">"using --no-slicing option to disable slicing"</span>,</span><br><span class="line">                     netdev_name);</span><br><span class="line">            netdev_close(netdev);</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(port, <span class="string">'\0'</span>, <span class="keyword">sizeof</span> *port);</span><br><span class="line"></span><br><span class="line">    list_init(&amp;port-&gt;queue_list);</span><br><span class="line">    port-&gt;dp = dp;</span><br><span class="line">    port-&gt;netdev = netdev;</span><br><span class="line">    port-&gt;port_no = port_no;</span><br><span class="line">    port-&gt;num_queues = num_queues;</span><br><span class="line">    list_push_back(&amp;dp-&gt;port_list, &amp;port-&gt;node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the ctlpath that this port has been added */</span></span><br><span class="line">    send_port_status(port, OFPPR_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以重点看一下 <strong>do_open_netdev</strong> 和 <strong>send_port_status</strong> 函数。</p>
<h2 id="do-open-netdev"><a href="#do-open-netdev" class="headerlink" title="do_open_netdev"></a>do_open_netdev</h2><p>此函数是以 <strong>netdev_open</strong> 函数作为入口被调用的，可以简单看一下 netdev_open 函数。</p>
<h3 id="netdev-open"><a href="#netdev-open" class="headerlink" title="netdev_open"></a>netdev_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Opens the network device named 'name' (e.g. "eth0") and returns zero if</span></span><br><span class="line"><span class="comment"> * successful, otherwise a positive errno value.  On success, sets '*netdevp'</span></span><br><span class="line"><span class="comment"> * to the new network device, otherwise to null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 'ethertype' may be a 16-bit Ethernet protocol value in host byte order to</span></span><br><span class="line"><span class="comment"> * capture frames of that type received on the device.  It may also be one of</span></span><br><span class="line"><span class="comment"> * the 'enum netdev_pseudo_ethertype' values to receive frames in one of those</span></span><br><span class="line"><span class="comment"> * categories. */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">netdev_open(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> ethertype, struct netdev **netdevp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">"tap:"</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> netdev_open_tap(name + <span class="number">4</span>, netdevp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> do_open_netdev(name, ethertype, <span class="number">-1</span>, netdevp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体比较简单，需要特地说明的是输入参数 <strong>ethertype</strong> 。该参数在 netdev_open 中的输入是 <strong>NETDEV_ETH_TYPE_ANY</strong> 。在 netdev.h 中有具体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> netdev_pseudo_ethertype &#123;</span><br><span class="line">    NETDEV_ETH_TYPE_NONE = <span class="number">-128</span>, <span class="comment">/* Receive no frames. */</span></span><br><span class="line">    NETDEV_ETH_TYPE_ANY,         <span class="comment">/* Receive all frames. */</span></span><br><span class="line">    NETDEV_ETH_TYPE_802_2        <span class="comment">/* Receive all IEEE 802.2 frames. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到 do_open_netdev 函数，该函数代码如下，不过多解释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">do_open_netdev(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> ethertype, <span class="keyword">int</span> tap_fd,</span><br><span class="line">               struct netdev **netdev_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> netdev_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sll</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ifindex;</span><br><span class="line">    <span class="keyword">uint8_t</span> etheraddr[ETH_ADDR_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">in6</span>;</span></span><br><span class="line">    <span class="keyword">int</span> mtu;</span><br><span class="line">    <span class="keyword">int</span> txqlen;</span><br><span class="line">    <span class="keyword">int</span> hwaddr_family;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev</span> *<span class="title">netdev</span>;</span></span><br><span class="line"></span><br><span class="line">    init_netdev();</span><br><span class="line">    *netdev_ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create raw socket. */</span></span><br><span class="line">    netdev_fd = socket(PF_PACKET, SOCK_RAW,</span><br><span class="line">                       htons(ethertype == NETDEV_ETH_TYPE_NONE ? <span class="number">0</span></span><br><span class="line">                             : ethertype == NETDEV_ETH_TYPE_ANY ? ETH_P_ALL</span><br><span class="line">                             : ethertype == NETDEV_ETH_TYPE_802_2 ? ETH_P_802_2</span><br><span class="line">                             : ethertype));</span><br><span class="line">    <span class="keyword">if</span> (netdev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set non-blocking mode. */</span></span><br><span class="line">    error = set_nonblocking(netdev_fd);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error_already_set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get ethernet device index. */</span></span><br><span class="line">    <span class="built_in">strncpy</span>(ifr.ifr_name, name, <span class="keyword">sizeof</span> ifr.ifr_name);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(netdev_fd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"ioctl(SIOCGIFINDEX) on %s device failed: %s"</span>,</span><br><span class="line">                 name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    ifindex = ifr.ifr_ifindex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bind to specific ethernet device. */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sll, <span class="number">0</span>, <span class="keyword">sizeof</span> sll);</span><br><span class="line">    sll.sll_family = AF_PACKET;</span><br><span class="line">    sll.sll_ifindex = ifindex;</span><br><span class="line">    <span class="keyword">if</span> (bind(netdev_fd, (struct sockaddr *) &amp;sll, <span class="keyword">sizeof</span> sll) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"bind to %s failed: %s"</span>, name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ethertype != NETDEV_ETH_TYPE_NONE) &#123;</span><br><span class="line">        <span class="comment">/* Between the socket() and bind() calls above, the socket receives all</span></span><br><span class="line"><span class="comment">         * packets of the requested type on all system interfaces.  We do not</span></span><br><span class="line"><span class="comment">         * want to receive that data, but there is no way to avoid it.  So we</span></span><br><span class="line"><span class="comment">         * must now drain out the receive queue. */</span></span><br><span class="line">        error = drain_rcvbuf(netdev_fd);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get MAC address. */</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(netdev_fd, SIOCGIFHWADDR, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"ioctl(SIOCGIFHWADDR) on %s device failed: %s"</span>,</span><br><span class="line">                 name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    hwaddr_family = ifr.ifr_hwaddr.sa_family;</span><br><span class="line">    <span class="keyword">if</span> (hwaddr_family != AF_UNSPEC &amp;&amp; hwaddr_family != ARPHRD_ETHER) &#123;</span><br><span class="line">        VLOG_WARN(<span class="string">"%s device has unknown hardware address family %d"</span>,</span><br><span class="line">                  name, hwaddr_family);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(etheraddr, ifr.ifr_hwaddr.sa_data, <span class="keyword">sizeof</span> etheraddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get MTU. */</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(netdev_fd, SIOCGIFMTU, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"ioctl(SIOCGIFMTU) on %s device failed: %s"</span>,</span><br><span class="line">                 name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    mtu = ifr.ifr_mtu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get TX queue length. */</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(netdev_fd, SIOCGIFTXQLEN, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"ioctl(SIOCGIFTXQLEN) on %s device failed: %s"</span>,</span><br><span class="line">                 name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    txqlen = ifr.ifr_qlen;</span><br><span class="line"></span><br><span class="line">    get_ipv6_address(name, &amp;in6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate network device. */</span></span><br><span class="line">    netdev = xmalloc(<span class="keyword">sizeof</span> *netdev);</span><br><span class="line">    netdev-&gt;name = xstrdup(name);</span><br><span class="line">    netdev-&gt;ifindex = ifindex;</span><br><span class="line">    netdev-&gt;txqlen = txqlen;</span><br><span class="line">    netdev-&gt;hwaddr_family = hwaddr_family;</span><br><span class="line">    netdev-&gt;netdev_fd = netdev_fd;</span><br><span class="line">    netdev-&gt;tap_fd = tap_fd &lt; <span class="number">0</span> ? netdev_fd : tap_fd;</span><br><span class="line">    netdev-&gt;queue_fd[<span class="number">0</span>] = netdev-&gt;tap_fd;</span><br><span class="line">    <span class="built_in">memcpy</span>(netdev-&gt;etheraddr, etheraddr, <span class="keyword">sizeof</span> etheraddr);</span><br><span class="line">    netdev-&gt;mtu = mtu;</span><br><span class="line">    netdev-&gt;in6 = in6;</span><br><span class="line">    netdev-&gt;num_queues = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get speed, features. */</span></span><br><span class="line">    do_ethtool(netdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save flags to restore at close or exit. */</span></span><br><span class="line">    error = get_flags(netdev-&gt;name, &amp;netdev-&gt;save_flags);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error_already_set;</span><br><span class="line">    &#125;</span><br><span class="line">    netdev-&gt;changed_flags = <span class="number">0</span>;</span><br><span class="line">    fatal_signal_block();</span><br><span class="line">    list_push_back(&amp;netdev_list, &amp;netdev-&gt;node);</span><br><span class="line">    fatal_signal_unblock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Success! */</span></span><br><span class="line">    *netdev_ = netdev;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    error = errno;</span><br><span class="line">error_already_set:</span><br><span class="line">    close(netdev_fd);</span><br><span class="line">    <span class="keyword">if</span> (tap_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(tap_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/07/24/post6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/24/post6/" itemprop="url">OpenFlow1.0.0 带无线扩展的OF1.0协议代码详解———main</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-24T09:19:39+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>openflow1.0.0</strong> 是斯坦福团队在2008年为满足AP在SDN系统中适配提出的openflow协议无线域扩展。此协议以openflow1.0为基础，解析处理 ieee80211 数据；利用 click 元素实现AP到控制器的转发功能。</p>
<p>这一篇文章从主函数出发，解读了代码的几个框架性函数。</p>
<p>主程序运行在 <strong>udatapath.c</strong> 中。</p>
<center><font size="8">从 main 函数开始解读</font>&gt;</center>

 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n_listeners;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    set_program_name(argv[<span class="number">0</span>]);  <span class="comment">//设置程序名</span></span><br><span class="line">    register_fault_handlers();  <span class="comment">//注册新号故障处理器</span></span><br><span class="line">    time_init();</span><br><span class="line">    vlog_init();</span><br><span class="line">    parse_options(argc, argv);  <span class="comment">//解析选项</span></span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>主要看一下 <strong>parse_options</strong> 函数，此函数定义了该子程序的解析选项。</p>
<h3 id="parse-options"><a href="#parse-options" class="headerlink" title="parse_options"></a>parse_options</h3><p>这里不是完整的函数代码，我们主要关注参数选项和对应的执行函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">parse_options(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] = &#123;</span></span><br><span class="line">        &#123;<span class="string">"interfaces"</span>,  required_argument, <span class="number">0</span>, <span class="string">'i'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"local-port"</span>,  required_argument, <span class="number">0</span>, <span class="string">'L'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"no-local-port"</span>, no_argument, <span class="number">0</span>, OPT_NO_LOCAL_PORT&#125;,</span><br><span class="line">        &#123;<span class="string">"datapath-id"</span>, required_argument, <span class="number">0</span>, <span class="string">'d'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"verbose"</span>,     optional_argument, <span class="number">0</span>, <span class="string">'v'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"help"</span>,        no_argument, <span class="number">0</span>, <span class="string">'h'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"version"</span>,     no_argument, <span class="number">0</span>, <span class="string">'V'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"no-slicing"</span>,  no_argument, <span class="number">0</span>, OPT_NO_SLICING&#125;,</span><br><span class="line">        &#123;<span class="string">"mfr-desc"</span>,    required_argument, <span class="number">0</span>, OPT_MFR_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"hw-desc"</span>,     required_argument, <span class="number">0</span>, OPT_HW_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"sw-desc"</span>,     required_argument, <span class="number">0</span>, OPT_SW_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"dp_desc"</span>,  required_argument, <span class="number">0</span>, OPT_DP_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"serial_num"</span>,  required_argument, <span class="number">0</span>, OPT_SERIAL_NUM&#125;,</span><br><span class="line">        DAEMON_LONG_OPTIONS,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> indexptr;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">        c = getopt_long(argc, argv, short_options, long_options, &amp;indexptr);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(optarg) != <span class="number">12</span></span><br><span class="line">                || <span class="built_in">strspn</span>(optarg, <span class="string">"0123456789abcdefABCDEF"</span>) != <span class="number">12</span>) &#123;</span><br><span class="line">                ofp_fatal(<span class="number">0</span>, <span class="string">"argument to -d or --datapath-id must be "</span></span><br><span class="line">                          <span class="string">"exactly 12 hex digits"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dpid = strtoll(optarg, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (!dpid) &#123;</span><br><span class="line">                ofp_fatal(<span class="number">0</span>, <span class="string">"argument to -d or --datapath-id must "</span></span><br><span class="line">                          <span class="string">"be nonzero"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            usage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s compiled "</span>__DATE__<span class="string">" "</span>__TIME__<span class="string">"\n"</span>,</span><br><span class="line">                   program_name, VERSION BUILDNR);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">            vlog_set_verbosity(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">            <span class="keyword">if</span> (!port_list) &#123;</span><br><span class="line">                port_list = optarg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                port_list = xasprintf(<span class="string">"%s,%s"</span>, port_list, optarg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            local_port = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_NO_LOCAL_PORT:</span><br><span class="line">            local_port = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_MFR_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(mfr_desc, optarg, <span class="keyword">sizeof</span> mfr_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_HW_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(hw_desc, optarg, <span class="keyword">sizeof</span> hw_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_SW_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(sw_desc, optarg, <span class="keyword">sizeof</span> sw_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_DP_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(dp_desc, optarg, <span class="keyword">sizeof</span> dp_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_SERIAL_NUM:</span><br><span class="line">            <span class="built_in">strncpy</span>(serial_num, optarg, <span class="keyword">sizeof</span> serial_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_NO_SLICING:</span><br><span class="line">            num_queues = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        DAEMON_OPTION_HANDLERS</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(short_options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主函数</strong>对程序输入参数进行排错判断</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc - optind &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    ofp_fatal(<span class="number">0</span>, <span class="string">"at least one listener argument is required; "</span></span><br><span class="line">      <span class="string">"use --help for usage"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立新的datapath</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error = dp_new(&amp;dp, dpid);</span><br></pre></td></tr></table></figure>
<p>查看 dp_new 函数</p>
<h3 id="dp-new"><a href="#dp-new" class="headerlink" title="dp_new"></a>dp_new</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">dp_new(struct datapath **dp_, <span class="keyword">uint64_t</span> dpid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">datapath</span> *<span class="title">dp</span>;</span></span><br><span class="line"></span><br><span class="line">    dp = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span> *dp);</span><br><span class="line">    <span class="keyword">if</span> (!dp) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp-&gt;last_timeout = time_now();</span><br><span class="line">    list_init(&amp;dp-&gt;remotes);</span><br><span class="line">    dp-&gt;listeners = <span class="literal">NULL</span>;</span><br><span class="line">    dp-&gt;n_listeners = <span class="number">0</span>;</span><br><span class="line">    dp-&gt;id = dpid &lt;= UINT64_C(<span class="number">0xffffffffffff</span>) ? dpid : gen_datapath_id();</span><br><span class="line">    dp-&gt;chain = chain_create(dp);  <span class="comment">//Creates and returns a new chain.</span></span><br><span class="line">    <span class="keyword">if</span> (!dp-&gt;chain) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"could not create chain"</span>);</span><br><span class="line">        <span class="built_in">free</span>(dp);</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;dp-&gt;port_list);</span><br><span class="line">    dp-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    dp-&gt;miss_send_len = OFP_DEFAULT_MISS_SEND_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(&amp;dp_desc) &gt; <span class="number">0</span>)	<span class="comment">/* use the comment, if specified */</span></span><br><span class="line">	    <span class="built_in">strncpy</span>(dp-&gt;dp_desc, &amp;dp_desc, <span class="keyword">sizeof</span> dp-&gt;dp_desc);</span><br><span class="line">    <span class="keyword">else</span>			            <span class="comment">/* else, just use "$HOSTNAME pid=$$" */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> hostnametmp[DESC_STR_LEN];</span><br><span class="line">	    gethostname(hostnametmp,<span class="keyword">sizeof</span> hostnametmp);</span><br><span class="line">        <span class="built_in">snprintf</span>(dp-&gt;dp_desc, <span class="keyword">sizeof</span> dp-&gt;dp_desc,<span class="string">"%s pid=%u"</span>,hostnametmp, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dp_ = dp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数对 datapath 结构体的各成员做出初始化定义，其中比较重要的是 chain ，一起来看一下 <strong>chain_create</strong> 结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Creates and returns a new chain.  Returns NULL if the chain cannot be</span></span><br><span class="line"><span class="comment"> * created. */</span></span><br><span class="line"><span class="function">struct sw_chain *<span class="title">chain_create</span><span class="params">(struct datapath *dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_chain</span> *<span class="title">chain</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span> *<span class="title">chain</span>);</span> <span class="comment">//分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    chain-&gt;dp = dp;</span><br><span class="line">    <span class="keyword">if</span> (add_table(chain, table_hash2_create(<span class="number">0x1EDC6F41</span>, TABLE_HASH_MAX_FLOWS,</span><br><span class="line">                                            <span class="number">0x741B8CD7</span>, TABLE_HASH_MAX_FLOWS),</span><br><span class="line">                                            <span class="number">0</span>)</span><br><span class="line">        || add_table(chain, table_linear_create(TABLE_LINEAR_MAX_FLOWS), <span class="number">0</span>)</span><br><span class="line">        || add_table(chain, table_linear_create(TABLE_LINEAR_MAX_FLOWS), <span class="number">1</span>)) &#123;</span><br><span class="line">        chain_destroy(chain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Attempts to append 'table' to the set of tables in 'chain'.  Returns 0 or</span></span><br><span class="line"><span class="comment"> * negative error.  If 'table' is null it is assumed that table creation failed</span></span><br><span class="line"><span class="comment"> * due to out-of-memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_table</span><span class="params">(struct sw_chain *chain, struct sw_table *table, <span class="keyword">int</span> emerg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (chain-&gt;n_tables &gt;= CHAIN_MAX_TABLES) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"too many tables in chain\n"</span>);</span><br><span class="line">        table-&gt;destroy(table);</span><br><span class="line">        <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (emerg)</span><br><span class="line">        chain-&gt;emerg_table = table;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        chain-&gt;tables[chain-&gt;n_tables++] = table;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 main 函数，这一段代码主要实现虚拟通道的建立和连接，不做详解。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">n_listeners = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = optind; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pvconn_name = argv[i];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pvconn</span> *<span class="title">pvconn</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = pvconn_open(pvconn_name, &amp;pvconn);</span><br><span class="line">    <span class="keyword">if</span> (!retval || retval == EAGAIN) &#123;</span><br><span class="line">        dp_add_pvconn(dp, pvconn);</span><br><span class="line">        n_listeners++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ofp_error(retval, <span class="string">"opening %s"</span>, pvconn_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!n_listeners) &#123;</span><br><span class="line">    ofp_fatal(<span class="number">0</span>, <span class="string">"could not listen for any connections"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (port_list) &#123;</span><br><span class="line">    add_ports(dp, port_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (local_port) &#123;</span><br><span class="line">    error = dp_add_local_port(dp, local_port, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        ofp_fatal(error, <span class="string">"failed to add local port %s"</span>, local_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = vlog_server_listen(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    ofp_fatal(error, <span class="string">"could not listen for vlog connections"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果相同程序以存在则停止此程序，运行守护进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">die_if_already_running();</span><br><span class="line">daemonize();</span><br></pre></td></tr></table></figure>
<h3 id="daemonize-void"><a href="#daemonize-void" class="headerlink" title="daemonize(void)"></a>daemonize(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">daemonize(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (detach) &#123;  <span class="comment">//detach是一个bool值，判断是否作为后台程序运行</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (pipe(fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ofp_fatal(errno, <span class="string">"pipe failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* Parent process: wait for child to create pidfile, then exit. */</span></span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            fatal_signal_fork();</span><br><span class="line">            <span class="keyword">if</span> (read(fds[<span class="number">0</span>], &amp;c, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">                ofp_fatal(errno, <span class="string">"daemon child failed to signal startup"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">/* Child process. */</span></span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            make_pidfile();  <span class="comment">//进程文件</span></span><br><span class="line">            write(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>);  <span class="comment">//读写操作</span></span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            setsid();</span><br><span class="line">            chdir(<span class="string">"/"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="comment">/* Error. */</span></span><br><span class="line">            ofp_fatal(errno, <span class="string">"could not fork"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        make_pidfile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，主函数建立socket通道。前面提到该AP由<strong>click</strong>模式实现与控制器或上层 openflow 交换机的交互，click相当于一个交换数据的交换机，用不同端口将数据交换隔离开。openflow1.0.0 程序建立 socket 通道，将数据包以 udp 协议传输到click模块中。通道由 make_socket 函数建立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*add the monitor function*/</span></span><br><span class="line">tp = <span class="built_in">realloc</span>(tp, <span class="keyword">sizeof</span>(struct thread_para));</span><br><span class="line">tp-&gt;dp = dp;</span><br><span class="line">make_socket(tp);</span><br></pre></td></tr></table></figure>
<h3 id="make-socket"><a href="#make-socket" class="headerlink" title="make_socket"></a>make_socket</h3><p>thread_para 是一个包含端口port和datapath的结构体，具体定义为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_para</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">border_port</span> *<span class="title">bp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">datapath</span> *<span class="title">dp</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server socket using UDP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_socket</span><span class="params">(struct thread_para *tp)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter make socket function\n"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SERV_PORT = <span class="number">5555</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr , <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET , SOCK_DGRAM , <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_fd = sockfd;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">border_port</span>* <span class="title">bp</span>;</span></span><br><span class="line">    bp = <span class="built_in">realloc</span>(bp, <span class="keyword">sizeof</span>(struct border_port));</span><br><span class="line">    tp-&gt;bp = bp;</span><br><span class="line">    tp-&gt;bp-&gt;fd = sockfd; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd , (struct sockaddr *)&amp;servaddr , <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create server socket\n"</span>);</span><br><span class="line">    <span class="comment">//create thread to send and receive message from click module</span></span><br><span class="line">    <span class="keyword">if</span>( pthread_create(&amp;tid, <span class="literal">NULL</span>, socket_handler, tp) != <span class="number">0</span> )</span><br><span class="line">        pdie(<span class="string">"pthread_create"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台进程建立成功后，主函数中设计了一个死循环，运行 <strong>dp_run, dp_wait, poll_back</strong> 三个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    dp_run(dp);</span><br><span class="line">    dp_wait(dp);</span><br><span class="line">    poll_block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要来看一下 dp_run 函数，其余的 dp_wait 和 poll_block 函数不做详解。</p>
<h3 id="dp-run"><a href="#dp-run" class="headerlink" title="dp_run"></a>dp_run</h3><p>此函数顾名思义就是运行一个datapath，其中主要重要的函数包括 <strong>netdev_recv</strong> 、<strong>fwd_port_input</strong> 和 <strong>remote_run</strong> ，将会在后面具体分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dp_run(struct datapath *dp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now = time_now();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_port</span> *<span class="title">p</span>, *<span class="title">pn</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remote</span> *<span class="title">r</span>, *<span class="title">rn</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *<span class="title">buffer</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now != dp-&gt;last_timeout) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">deleted</span> = <span class="title">LIST_INITIALIZER</span>(&amp;<span class="title">deleted</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">f</span>, *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">        chain_timeout(dp-&gt;chain, &amp;deleted);</span><br><span class="line">        LIST_FOR_EACH_SAFE (f, n, struct sw_flow, node, &amp;deleted) &#123;</span><br><span class="line">            dp_send_flow_end(dp, f, f-&gt;reason);</span><br><span class="line">            list_remove(&amp;f-&gt;node);</span><br><span class="line">            flow_free(f);</span><br><span class="line">        &#125;</span><br><span class="line">        dp-&gt;last_timeout = now;</span><br><span class="line">    &#125;</span><br><span class="line">    poll_timer_wait(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以上对超时做了排错处理</span></span><br><span class="line"><span class="comment"> * dp_send_flow_end 将错误代码发送到控制器，具体分析见下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    LIST_FOR_EACH_SAFE (p, pn, struct sw_port, node, &amp;dp-&gt;port_list) &#123;</span><br><span class="line">        <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">            <span class="comment">/* Allocate buffer with some headroom to add headers in forwarding</span></span><br><span class="line"><span class="comment">             * to the controller or adding a vlan tag, plus an extra 2 bytes to</span></span><br><span class="line"><span class="comment">             * allow IP headers to be aligned on a 4-byte boundary.  */</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> headroom = <span class="number">128</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> hard_header = VLAN_ETH_HEADER_LEN;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> mtu = netdev_get_mtu(p-&gt;netdev);</span><br><span class="line">            buffer = ofpbuf_new(headroom + hard_header + mtu);</span><br><span class="line">            buffer-&gt;data = (<span class="keyword">char</span>*)buffer-&gt;data + headroom;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * buffer用来暂时存储netdevice的数据包</span></span><br><span class="line"><span class="comment">  * ofbuf_new 定义了一个空的buffer空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        error = netdev_recv(p-&gt;netdev, buffer);</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            p-&gt;rx_packets++;</span><br><span class="line">            p-&gt;rx_bytes += buffer-&gt;size;</span><br><span class="line">            fwd_port_input(dp, buffer, p);</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != EAGAIN) &#123;</span><br><span class="line">            VLOG_ERR_RL(&amp;rl, <span class="string">"error receiving data from %s: %s"</span>,</span><br><span class="line">                        netdev_get_name(p-&gt;netdev), strerror(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ofpbuf_delete(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 建立与Controller之间的安全信道</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Talk to remotes. */</span></span><br><span class="line">    LIST_FOR_EACH_SAFE (r, rn, struct remote, node, &amp;dp-&gt;remotes) &#123;</span><br><span class="line">        remote_run(dp, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dp-&gt;n_listeners; ) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pvconn</span> *<span class="title">pvconn</span> = <span class="title">dp</span>-&gt;<span class="title">listeners</span>[<span class="title">i</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> *<span class="title">new_vconn</span>;</span></span><br><span class="line">        <span class="keyword">int</span> retval = pvconn_accept(pvconn, OFP_VERSION, &amp;new_vconn);</span><br><span class="line">        <span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">            remote_create(dp, rconn_new_from_vconn(<span class="string">"passive"</span>, new_vconn));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval != EAGAIN) &#123;</span><br><span class="line">            VLOG_WARN_RL(&amp;rl, <span class="string">"accept failed (%s)"</span>, strerror(retval));</span><br><span class="line">            dp-&gt;listeners[i] = dp-&gt;listeners[--dp-&gt;n_listeners];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ofpbuf_new</strong> 提供一个空的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *</span></span><br><span class="line"><span class="class"><span class="title">ofpbuf_new</span>(<span class="title">size_t</span> <span class="title">size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *<span class="title">b</span> = <span class="title">xmalloc</span>(<span class="title">sizeof</span> *<span class="title">b</span>);</span></span><br><span class="line">    ofpbuf_init(b, size);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="netdev-recv"><a href="#netdev-recv" class="headerlink" title="netdev_recv"></a>netdev_recv</h4><p><strong>netdev_recv</strong> 将网络设备接受到的数据包存进缓存空间。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">netdev_recv(struct netdev *netdev, struct ofpbuf *buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n_bytes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sll</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> sll_len;</span><br><span class="line"></span><br><span class="line">    assert(buffer-&gt;size == <span class="number">0</span>);</span><br><span class="line">    assert(ofpbuf_tailroom(buffer) &gt;= ETH_TOTAL_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* prepare to call recvfrom */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sll,<span class="number">0</span>,<span class="keyword">sizeof</span> sll);</span><br><span class="line">    sll_len = <span class="keyword">sizeof</span> sll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cannot execute recvfrom over a tap device */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(netdev-&gt;name, <span class="string">"tap"</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            n_bytes = read(netdev-&gt;tap_fd, ofpbuf_tail(buffer),</span><br><span class="line">                           (<span class="keyword">ssize_t</span>)ofpbuf_tailroom(buffer));</span><br><span class="line">        &#125; <span class="keyword">while</span> (n_bytes &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            n_bytes = recvfrom(netdev-&gt;tap_fd, ofpbuf_tail(buffer),</span><br><span class="line">                               (<span class="keyword">ssize_t</span>)ofpbuf_tailroom(buffer), <span class="number">0</span>,</span><br><span class="line">                               (struct sockaddr *)&amp;sll, &amp;sll_len);</span><br><span class="line">        &#125; <span class="keyword">while</span> (n_bytes &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n_bytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            VLOG_WARN_RL(&amp;rl, <span class="string">"error receiving Ethernet packet on %s: %s"</span>,</span><br><span class="line">                         strerror(errno), netdev-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* we have multiple raw sockets at the same interface, so we also</span></span><br><span class="line"><span class="comment">         * receive what others send, and need to filter them out.</span></span><br><span class="line"><span class="comment">         * TODO(yiannisy): can we install this as a BPF at kernel? */</span></span><br><span class="line">        <span class="keyword">if</span> (sll.sll_pkttype == PACKET_OUTGOING) &#123;</span><br><span class="line">            <span class="keyword">return</span> EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        buffer-&gt;size += n_bytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the kernel internally sends out an Ethernet frame on an</span></span><br><span class="line"><span class="comment">         * interface, it gives us a copy *before* padding the frame to the</span></span><br><span class="line"><span class="comment">         * minimum length.  Thus, when it sends out something like an ARP</span></span><br><span class="line"><span class="comment">         * request, we see a too-short frame.  So pad it out to the minimum</span></span><br><span class="line"><span class="comment">         * length. */</span></span><br><span class="line">        pad_to_minimum_length(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数利用 <a href="https://blog.csdn.net/liangkaiyang/article/details/5931901" target="_blank" rel="noopener"><strong>recvfrom</strong></a> 函数将网络设备收到的数据存储在 buffer 的 ofpbuf_tail 中。接受到数据包之后， <strong>fwd_port_input</strong> 函数首先对其处理。</p>
<h4 id="fwd-port-input"><a href="#fwd-port-input" class="headerlink" title="fwd_port_input"></a>fwd_port_input</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 'buffer' was received on 'p', which may be a a physical switch port or a</span></span><br><span class="line"><span class="comment"> * null pointer.  Process it according to 'dp''s flow table, sending it up to</span></span><br><span class="line"><span class="comment"> * the controller if no flow matches.  Takes ownership of 'buffer'. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwd_port_input</span><span class="params">(struct datapath *dp, struct ofpbuf *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sw_port *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (run_flow_through_tables(dp, buffer, p)) &#123;</span><br><span class="line">        dp_output_control(dp, buffer, p-&gt;port_no,</span><br><span class="line">                          dp-&gt;miss_send_len, OFPR_NO_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据包首先由 <strong>run_flow_through_tables</strong> 判断是否需要输出至控制器，再由 <strong>dp_output_control</strong> 函数操作。</p>
<h4 id="run-flow-through-tables"><a href="#run-flow-through-tables" class="headerlink" title="run_flow_through_tables"></a>run_flow_through_tables</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 'buffer' was received on 'p', which may be a a physical switch port or a</span></span><br><span class="line"><span class="comment"> * null pointer.  Process it according to 'dp''s flow table.  Returns 0 if</span></span><br><span class="line"><span class="comment"> * successful, in which case 'buffer' is destroyed, or -ESRCH if there is no</span></span><br><span class="line"><span class="comment"> * matching flow, in which case 'buffer' still belongs to the caller. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_flow_through_tables</span><span class="params">(struct datapath *dp, struct ofpbuf *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct sw_port *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_key</span> <span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span>;</span></span><br><span class="line"></span><br><span class="line">    key.wildcards = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (flow_extract(buffer, p ? p-&gt;port_no : OFPP_NONE, &amp;key.flow)</span><br><span class="line">        &amp;&amp; (dp-&gt;flags &amp; OFPC_FRAG_MASK) == OFPC_FRAG_DROP) &#123;</span><br><span class="line">        <span class="comment">/* Drop fragment. */</span></span><br><span class="line">        ofpbuf_delete(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;config &amp; (OFPPC_NO_RECV | OFPPC_NO_RECV_STP)</span><br><span class="line">        &amp;&amp; p-&gt;config &amp; (!eth_addr_equals(key.flow.dl_dst, stp_eth_addr)</span><br><span class="line">                       ? OFPPC_NO_RECV : OFPPC_NO_RECV_STP)) &#123;</span><br><span class="line">        ofpbuf_delete(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow = chain_lookup(dp-&gt;chain, &amp;key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        flow_used(flow, buffer);</span><br><span class="line">        execute_actions(dp, buffer, &amp;key, flow-&gt;sf_acts-&gt;actions,</span><br><span class="line">                        flow-&gt;sf_acts-&gt;actions_len, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -ESRCH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<strong>flow_extract</strong> 解析数据包，该函数主要判断数据包是否为IP数据包，是则返回1；否则返回0。如果是IP数据包，程序将删除这一缓存，不进行下一步处理。同时，函数将数据包中的各信息位信息存储到结构体 <strong>flow</strong> 中。flow 由 sw_flow 定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_key</span> <span class="title">key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> cookie;            <span class="comment">/* Opaque controller-issued identifier. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> priority;          <span class="comment">/* Only used on entries with wildcards. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> idle_timeout;      <span class="comment">/* Idle time before discarding (seconds). */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hard_timeout;      <span class="comment">/* Hard expiration time (seconds) */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> used;              <span class="comment">/* Last used time. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> created;           <span class="comment">/* When the flow was created. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> packet_count;      <span class="comment">/* Number of packets seen. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> byte_count;        <span class="comment">/* Number of bytes seen. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reason;             <span class="comment">/* Reason flow removed (one of OFPRR_*). */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> send_flow_rem;      <span class="comment">/* Send a flow removed to the controller */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> emerg_flow;         <span class="comment">/* Emergency flow indicator */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sf_acts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Private to table implementations. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">iter_node</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> serial;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数据流解析函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns 1 if 'packet' is an IP fragment, 0 otherwise. */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">flow_extract(struct ofpbuf *packet, <span class="keyword">uint16_t</span> in_port, struct flow *flow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> <span class="title">b</span> = *<span class="title">packet</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eth_header</span> *<span class="title">eth</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(flow, <span class="number">0</span>, <span class="keyword">sizeof</span> *flow);</span><br><span class="line">    flow-&gt;dl_vlan = htons(OFP_VLAN_NONE);</span><br><span class="line">    flow-&gt;in_port = htons(in_port);</span><br><span class="line"></span><br><span class="line">    packet-&gt;l2 = b.data;</span><br><span class="line">    packet-&gt;l3 = <span class="literal">NULL</span>;</span><br><span class="line">    packet-&gt;l4 = <span class="literal">NULL</span>;</span><br><span class="line">    packet-&gt;l7 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    eth = pull_eth(&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (eth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ntohs(eth-&gt;eth_type) &gt;= OFP_DL_TYPE_ETH2_CUTOFF) &#123;</span><br><span class="line">            <span class="comment">/* This is an Ethernet II frame */</span></span><br><span class="line">            flow-&gt;dl_type = eth-&gt;eth_type;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* This is an 802.2 frame */</span></span><br><span class="line">            struct llc_header *llc = ofpbuf_at(&amp;b, <span class="number">0</span>, <span class="keyword">sizeof</span> *llc);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">snap_header</span> *<span class="title">snap</span> = <span class="title">ofpbuf_at</span>(&amp;<span class="title">b</span>, <span class="title">sizeof</span> *<span class="title">llc</span>,</span></span><br><span class="line"><span class="class">                                                 <span class="title">sizeof</span> *<span class="title">snap</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (llc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (snap</span><br><span class="line">                &amp;&amp; llc-&gt;llc_dsap == LLC_DSAP_SNAP</span><br><span class="line">                &amp;&amp; llc-&gt;llc_ssap == LLC_SSAP_SNAP</span><br><span class="line">                &amp;&amp; llc-&gt;llc_cntl == LLC_CNTL_SNAP</span><br><span class="line">                &amp;&amp; !<span class="built_in">memcmp</span>(snap-&gt;snap_org, SNAP_ORG_ETHERNET,</span><br><span class="line">                           <span class="keyword">sizeof</span> snap-&gt;snap_org)) &#123;</span><br><span class="line">                flow-&gt;dl_type = snap-&gt;snap_type;</span><br><span class="line">                ofpbuf_pull(&amp;b, LLC_SNAP_HEADER_LEN);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flow-&gt;dl_type = htons(OFP_DL_TYPE_NOT_ETH_TYPE);</span><br><span class="line">                ofpbuf_pull(&amp;b, <span class="keyword">sizeof</span>(struct llc_header));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check for a VLAN tag */</span></span><br><span class="line">        <span class="keyword">if</span> (flow-&gt;dl_type == htons(ETH_TYPE_VLAN)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vlan_header</span> *<span class="title">vh</span> = <span class="title">pull_vlan</span>(&amp;<span class="title">b</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (vh) &#123;</span><br><span class="line">                flow-&gt;dl_type = vh-&gt;vlan_next_type;</span><br><span class="line">                flow-&gt;dl_vlan = vh-&gt;vlan_tci &amp; htons(VLAN_VID_MASK);</span><br><span class="line">                flow-&gt;dl_vlan_pcp = (<span class="keyword">uint8_t</span>)((ntohs(vh-&gt;vlan_tci) &gt;&gt; VLAN_PCP_SHIFT)</span><br><span class="line">                                               &amp; VLAN_PCP_BITMASK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(flow-&gt;dl_src, eth-&gt;eth_src, ETH_ADDR_LEN);</span><br><span class="line">        <span class="built_in">memcpy</span>(flow-&gt;dl_dst, eth-&gt;eth_dst, ETH_ADDR_LEN);</span><br><span class="line"></span><br><span class="line">        packet-&gt;l3 = b.data;</span><br><span class="line">        <span class="keyword">if</span> (flow-&gt;dl_type == htons(ETH_TYPE_IP)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_header</span> *<span class="title">nh</span> = <span class="title">pull_ip</span>(&amp;<span class="title">b</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (nh) &#123;</span><br><span class="line">                flow-&gt;nw_tos = nh-&gt;ip_tos &amp; <span class="number">0xfc</span>;</span><br><span class="line">                flow-&gt;nw_proto = nh-&gt;ip_proto;</span><br><span class="line">                flow-&gt;nw_src = nh-&gt;ip_src;</span><br><span class="line">                flow-&gt;nw_dst = nh-&gt;ip_dst;</span><br><span class="line">                packet-&gt;l4 = b.data;</span><br><span class="line">                <span class="keyword">if</span> (!IP_IS_FRAGMENT(nh-&gt;ip_frag_off)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (flow-&gt;nw_proto == IP_TYPE_TCP) &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span> *<span class="title">tcp</span> = <span class="title">pull_tcp</span>(&amp;<span class="title">b</span>);</span></span><br><span class="line">                        <span class="keyword">if</span> (tcp) &#123;</span><br><span class="line">                            flow-&gt;tp_src = tcp-&gt;tcp_src;</span><br><span class="line">                            flow-&gt;tp_dst = tcp-&gt;tcp_dst;</span><br><span class="line">                            packet-&gt;l7 = b.data;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Avoid tricking other code into thinking that</span></span><br><span class="line"><span class="comment">                             * this packet has an L4 header. */</span></span><br><span class="line">                            flow-&gt;nw_proto = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow-&gt;nw_proto == IP_TYPE_UDP) &#123;</span><br><span class="line">                        <span class="keyword">const</span> struct udp_header *udp = pull_udp(&amp;b);</span><br><span class="line">                        <span class="keyword">if</span> (udp) &#123;</span><br><span class="line">                            flow-&gt;tp_src = udp-&gt;udp_src;</span><br><span class="line">                            flow-&gt;tp_dst = udp-&gt;udp_dst;</span><br><span class="line">                            packet-&gt;l7 = b.data;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Avoid tricking other code into thinking that</span></span><br><span class="line"><span class="comment">                             * this packet has an L4 header. */</span></span><br><span class="line">                            flow-&gt;nw_proto = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow-&gt;nw_proto == IP_TYPE_ICMP) &#123;</span><br><span class="line">                        <span class="keyword">const</span> struct icmp_header *icmp = pull_icmp(&amp;b);</span><br><span class="line">                        <span class="keyword">if</span> (icmp) &#123;</span><br><span class="line">                            flow-&gt;icmp_type = htons(icmp-&gt;icmp_type);</span><br><span class="line">                            flow-&gt;icmp_code = htons(icmp-&gt;icmp_code);</span><br><span class="line">                            packet-&gt;l7 = b.data;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Avoid tricking other code into thinking that</span></span><br><span class="line"><span class="comment">                             * this packet has an L4 header. */</span></span><br><span class="line">                            flow-&gt;nw_proto = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    retval = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow-&gt;dl_type == htons(ETH_TYPE_ARP)) &#123;</span><br><span class="line">            <span class="keyword">const</span> struct arp_eth_header *arp = pull_arp(&amp;b);</span><br><span class="line">            <span class="keyword">if</span> (arp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arp-&gt;ar_pro == htons(ARP_PRO_IP) &amp;&amp; arp-&gt;ar_pln == IP_ADDR_LEN) &#123;</span><br><span class="line">                    flow-&gt;nw_src = arp-&gt;ar_spa;</span><br><span class="line">                    flow-&gt;nw_dst = arp-&gt;ar_tpa;</span><br><span class="line">                &#125;</span><br><span class="line">                flow-&gt;nw_proto = ntohs(arp-&gt;ar_op) &amp;&amp; <span class="number">0xff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是一个IP数据，数据包的信息现已存储在结构体 <strong>flow</strong> 中。</p>
<p>接着，通过 <strong>chain_lookup</strong> 函数为此数据包匹配对应的 <strong>key</strong> 并存入 <strong>flow</strong> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Searches 'chain' for a flow matching 'key', which must not have any wildcard</span></span><br><span class="line"><span class="comment"> * fields.  Returns the flow if successful, otherwise a null pointer. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *</span></span><br><span class="line"><span class="class"><span class="title">chain_lookup</span>(<span class="title">struct</span> <span class="title">sw_chain</span> *<span class="title">chain</span>, <span class="title">const</span> <span class="title">struct</span> <span class="title">sw_flow_key</span> *<span class="title">key</span>, <span class="title">int</span> <span class="title">emerg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    assert(!key-&gt;wildcards);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (emerg) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_table</span> *<span class="title">t</span> = <span class="title">chain</span>-&gt;<span class="title">emerg_table</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span> = <span class="title">t</span>-&gt;<span class="title">lookup</span>(<span class="title">t</span>, <span class="title">key</span>);</span></span><br><span class="line">        t-&gt;n_lookup++;</span><br><span class="line">        <span class="keyword">if</span> (flow) &#123;</span><br><span class="line">            t-&gt;n_matched++;</span><br><span class="line">            <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chain-&gt;n_tables; i++) &#123;</span><br><span class="line">            struct sw_table *t = chain-&gt;tables[i];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span> = <span class="title">t</span>-&gt;<span class="title">lookup</span>(<span class="title">t</span>, <span class="title">key</span>);</span></span><br><span class="line">            t-&gt;n_lookup++;</span><br><span class="line">            <span class="keyword">if</span> (flow) &#123;</span><br><span class="line">                t-&gt;n_matched++;</span><br><span class="line">                <span class="keyword">return</span> flow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后， <strong>execute_actions</strong> 函数执行该flow的 <strong>action</strong> 。</p>
<h4 id="execute-actions"><a href="#execute-actions" class="headerlink" title="execute_actions"></a>execute_actions</h4><p>此函数需要的参数包括 datapath，buffer，key，acitons，actions_len。</p>
<p>由函数的调用可以看到，actions 和 actions_len 存储在flow的 <strong>sw_flow_actions</strong> 结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute a list of actions against 'buffer'. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_actions</span><span class="params">(struct datapath *dp, struct ofpbuf *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">             struct sw_flow_key *key,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct ofp_action_header *actions, <span class="keyword">size_t</span> actions_len,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> ignore_no_fwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Every output action needs a separate clone of 'buffer', but the common</span></span><br><span class="line"><span class="comment">     * case is just a single output action, so that doing a clone and then</span></span><br><span class="line"><span class="comment">     * freeing the original buffer is wasteful.  So the following code is</span></span><br><span class="line"><span class="comment">     * slightly obscure just to avoid that. */</span></span><br><span class="line">    <span class="keyword">int</span> prev_port;</span><br><span class="line">    <span class="keyword">uint32_t</span> prev_queue;</span><br><span class="line">    <span class="keyword">size_t</span> max_len = UINT16_MAX;</span><br><span class="line">    <span class="keyword">uint16_t</span> in_port = ntohs(key-&gt;flow.in_port);</span><br><span class="line">    <span class="keyword">uint8_t</span> *p = (<span class="keyword">uint8_t</span> *)actions;</span><br><span class="line"></span><br><span class="line">    prev_port = <span class="number">-1</span>;</span><br><span class="line">    prev_queue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The action list was already validated, so we can be a bit looser</span></span><br><span class="line"><span class="comment">     * in our sanity-checking. */</span></span><br><span class="line">    <span class="keyword">while</span> (actions_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ofp_action_header</span> *<span class="title">ah</span> = (<span class="title">struct</span> <span class="title">ofp_action_header</span> *)<span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> len = htons(ah-&gt;len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev_port != <span class="number">-1</span>) &#123;</span><br><span class="line">            do_output(dp, ofpbuf_clone(buffer), in_port, max_len,</span><br><span class="line">                      prev_port, prev_queue, ignore_no_fwd);</span><br><span class="line">            prev_port = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ah-&gt;type == htons(OFPAT_OUTPUT)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ofp_action_output</span> *<span class="title">oa</span> = (<span class="title">struct</span> <span class="title">ofp_action_output</span> *)<span class="title">p</span>;</span></span><br><span class="line">            prev_port = ntohs(oa-&gt;port);</span><br><span class="line">            prev_queue = <span class="number">0</span>; <span class="comment">/* using the default best-effort queue */</span></span><br><span class="line">            max_len = ntohs(oa-&gt;max_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ah-&gt;type == htons(OFPAT_ENQUEUE)) &#123;</span><br><span class="line">            struct ofp_action_enqueue *ea = (struct ofp_action_enqueue *)p;</span><br><span class="line">            prev_port = ntohs(ea-&gt;port);</span><br><span class="line">            prev_queue = ntohl(ea-&gt;queue_id);</span><br><span class="line">            max_len = <span class="number">0</span>; <span class="comment">/* we will not send to the controller anyways - useless */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">uint16_t</span> type = ntohs(ah-&gt;type);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type &lt; ARRAY_SIZE(of_actions)) &#123;</span><br><span class="line">                execute_ofpat(buffer, key, ah, type);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == OFPAT_VENDOR) &#123;</span><br><span class="line">                execute_vendor(buffer, key, ah);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p += len;</span><br><span class="line">        actions_len -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev_port != <span class="number">-1</span>) &#123;</span><br><span class="line">        do_output(dp, buffer, in_port, max_len, prev_port, prev_queue, ignore_no_fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ofpbuf_delete(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数确定转发前后的端口，对 OpenFlow 协议的 build-in action 和 vendor aciton 分别执行 <strong>execute_ofpact</strong> 和 <strong>execute_vendor</strong> ，其他 actions 统一由 <strong>do_output</strong> 执行。</p>
<h4 id="do-output"><a href="#do-output" class="headerlink" title="do_output"></a>do_output</h4><p>函数首先根据输出端口判断该数据包是转发给控制器的还是由端口输出的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_output(struct datapath *dp, struct ofpbuf *buffer, <span class="keyword">int</span> in_port,</span><br><span class="line">          <span class="keyword">size_t</span> max_len, <span class="keyword">int</span> out_port, <span class="keyword">uint32_t</span> queue_id,</span><br><span class="line">          <span class="keyword">bool</span> ignore_no_fwd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (out_port != OFPP_CONTROLLER) &#123;</span><br><span class="line">        dp_output_port(dp, buffer, in_port, out_port, queue_id, ignore_no_fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp_output_control(dp, buffer, in_port, max_len, OFPR_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="do-output-port"><a href="#do-output-port" class="headerlink" title="do_output_port"></a>do_output_port</h5><p>根据不同的 out_port 对数据包进行处理，涉及的处理函数有 <strong>output_packet</strong> ，<strong>output_all</strong> 和 <strong>dp_output_control</strong> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Takes ownership of 'buffer' and transmits it to 'out_port' on 'dp'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dp_output_port(struct datapath *dp, struct ofpbuf *buffer,</span><br><span class="line">               <span class="keyword">int</span> in_port, <span class="keyword">int</span> out_port, <span class="keyword">uint32_t</span> queue_id,</span><br><span class="line">               <span class="keyword">bool</span> ignore_no_fwd UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    assert(buffer);</span><br><span class="line">    <span class="keyword">switch</span> (out_port) &#123;</span><br><span class="line">    <span class="keyword">case</span> OFPP_IN_PORT:</span><br><span class="line">        output_packet(dp, buffer, in_port, queue_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_TABLE: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_port</span> *<span class="title">p</span> = <span class="title">dp_lookup_port</span>(<span class="title">dp</span>, <span class="title">in_port</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (run_flow_through_tables(dp, buffer, p)) &#123;</span><br><span class="line">            ofpbuf_delete(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_FLOOD:</span><br><span class="line">        output_all(dp, buffer, in_port, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_ALL:</span><br><span class="line">        output_all(dp, buffer, in_port, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_CONTROLLER:</span><br><span class="line">        dp_output_control(dp, buffer, in_port, UINT16_MAX, OFPR_ACTION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_LOCAL:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (in_port == out_port) &#123;</span><br><span class="line">            VLOG_DBG_RL(&amp;rl, <span class="string">"can't directly forward to input port"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output_packet(dp, buffer, out_port, queue_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>output_packet 函数利用 <strong>netdev_send</strong> 函数将数据包由网络设备发出。</li>
<li>output_all 函数将数据包从所有端口发出，在函数内调用 do_output_port ，每次发送后将端口号加1继续发送。</li>
</ul>
<h5 id="do-output-control"><a href="#do-output-control" class="headerlink" title="do_output_control"></a>do_output_control</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Takes ownership of 'buffer' and transmits it to 'dp''s controller.  If the</span></span><br><span class="line"><span class="comment"> * packet can be saved in a buffer, then only the first max_len bytes of</span></span><br><span class="line"><span class="comment"> * 'buffer' are sent; otherwise, all of 'buffer' is sent.  'reason' indicates</span></span><br><span class="line"><span class="comment"> * why 'buffer' is being sent. 'max_len' sets the maximum number of bytes that</span></span><br><span class="line"><span class="comment"> * the caller wants to be sent. */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dp_output_control(struct datapath *dp, struct ofpbuf *buffer, <span class="keyword">int</span> in_port,</span><br><span class="line">                  <span class="keyword">size_t</span> max_len, <span class="keyword">int</span> reason)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofp_packet_in</span> *<span class="title">opi</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> total_len;</span><br><span class="line">    <span class="keyword">uint32_t</span> buffer_id;</span><br><span class="line"></span><br><span class="line">    buffer_id = save_buffer(buffer);</span><br><span class="line">    total_len = buffer-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (buffer_id != UINT32_MAX &amp;&amp; buffer-&gt;size &gt; max_len) &#123;</span><br><span class="line">        buffer-&gt;size = max_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opi = ofpbuf_push_uninit(buffer, offsetof(struct ofp_packet_in, data));</span><br><span class="line">    opi-&gt;header.version = OFP_VERSION;</span><br><span class="line">    opi-&gt;header.type    = OFPT_PACKET_IN;</span><br><span class="line">    opi-&gt;header.length  = htons(buffer-&gt;size);</span><br><span class="line">    opi-&gt;header.xid     = htonl(<span class="number">0</span>);</span><br><span class="line">    opi-&gt;buffer_id      = htonl(buffer_id);</span><br><span class="line">    opi-&gt;total_len      = htons(total_len);</span><br><span class="line">    opi-&gt;in_port        = htons(in_port);</span><br><span class="line">    opi-&gt;reason         = reason;</span><br><span class="line">    opi-&gt;pad            = <span class="number">0</span>;</span><br><span class="line">    send_openflow_buffer(dp, buffer, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数利用 <strong>ofpbuf_push_uninit</strong> 函数重构 buffer 的数据包头部，然后用 <strong>send_openflow_buffer</strong> 函数将 buffer 发出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ofpbuf_push_uninit(struct ofpbuf *b, <span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    ofpbuf_prealloc_headroom(b, size);</span><br><span class="line">    b-&gt;data = (<span class="keyword">char</span>*)b-&gt;data - size;</span><br><span class="line">    b-&gt;size += size;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析 send_openflow_buffer 函数之前，先来看一下之前提到的 <strong>remote_run</strong> 函数。</p>
<h4 id="remote-run"><a href="#remote-run" class="headerlink" title="remote_run"></a>remote_run</h4><p>此函数主要通过构建虚拟连接来建立一个远程进程，我的个人理解是通过这个函数来建立AP与Controller之间的安全信道。</p>
<p>首先，结构体 <strong>remote</strong> 构建了一个安全信道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A connection to a secure channel. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remote</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rconn</span> *<span class="title">rconn</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TXQ_LIMIT 128           <span class="comment">/* Max number of packets to queue for tx. */</span></span></span><br><span class="line">    <span class="keyword">int</span> n_txq;                  <span class="comment">/* Number of packets queued for tx on rconn. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Support for reliable, multi-message replies to requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If an incoming request needs to have a reliable reply that might</span></span><br><span class="line"><span class="comment">     * require multiple messages, it can use remote_start_dump() to set up</span></span><br><span class="line"><span class="comment">     * a callback that will be called as buffer space for replies. */</span></span><br><span class="line">    <span class="keyword">int</span> (*cb_dump)(struct datapath *, <span class="keyword">void</span> *aux);</span><br><span class="line">    <span class="keyword">void</span> (*cb_done)(<span class="keyword">void</span> *aux);</span><br><span class="line">    <span class="keyword">void</span> *cb_aux;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体 <strong>rconn</strong> 被定义为一个连接控制器或交换机的可靠连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A reliable connection to an OpenFlow switch or controller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See the large comment in rconn.h for more information. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rconn</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> state state;</span><br><span class="line">    <span class="keyword">time_t</span> state_entered;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> *<span class="title">vconn</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">bool</span> reliable;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofp_queue</span> <span class="title">txq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> backoff;</span><br><span class="line">    <span class="keyword">int</span> max_backoff;</span><br><span class="line">    <span class="keyword">time_t</span> backoff_deadline;</span><br><span class="line">    <span class="keyword">time_t</span> last_received;</span><br><span class="line">    <span class="keyword">time_t</span> last_connected;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packets_sent;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seqno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In S_ACTIVE and S_IDLE, probably_admitted reports whether we believe</span></span><br><span class="line"><span class="comment">     * that the peer has made a (positive) admission control decision on our</span></span><br><span class="line"><span class="comment">     * connection.  If we have not yet been (probably) admitted, then the</span></span><br><span class="line"><span class="comment">     * connection does not reset the timer used for deciding whether the switch</span></span><br><span class="line"><span class="comment">     * should go into fail-open mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * last_admitted reports the last time we believe such a positive admission</span></span><br><span class="line"><span class="comment">     * control decision was made. */</span></span><br><span class="line">    <span class="keyword">bool</span> probably_admitted;</span><br><span class="line">    <span class="keyword">time_t</span> last_admitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These values are simply for statistics reporting, not used directly by</span></span><br><span class="line"><span class="comment">     * anything internal to the rconn (or the secchan for that matter). */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packets_received;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n_attempted_connections, n_successful_connections;</span><br><span class="line">    <span class="keyword">time_t</span> creation_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> total_time_connected;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we can't connect to the peer, it could be for any number of reasons.</span></span><br><span class="line"><span class="comment">     * Usually, one would assume it is because the peer is not running or</span></span><br><span class="line"><span class="comment">     * because the network is partitioned.  But it could also be because the</span></span><br><span class="line"><span class="comment">     * network topology has changed, in which case the upper layer will need to</span></span><br><span class="line"><span class="comment">     * reassess it (in particular, obtain a new IP address via DHCP and find</span></span><br><span class="line"><span class="comment">     * the new location of the controller).  We set this flag when we suspect</span></span><br><span class="line"><span class="comment">     * that this could be the case. */</span></span><br><span class="line">    <span class="keyword">bool</span> questionable_connectivity;</span><br><span class="line">    <span class="keyword">time_t</span> last_questioned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Throughout this file, "probe" is shorthand for "inactivity probe".</span></span><br><span class="line"><span class="comment">     * When nothing has been received from the peer for a while, we send out</span></span><br><span class="line"><span class="comment">     * an echo request as an inactivity probe packet.  We should receive back</span></span><br><span class="line"><span class="comment">     * a response. */</span></span><br><span class="line">    <span class="keyword">int</span> probe_interval;         <span class="comment">/* Secs of inactivity before sending probe. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Messages sent or received are copied to the monitor connections. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MONITORS 8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> *<span class="title">monitors</span>[8];</span></span><br><span class="line">    <span class="keyword">size_t</span> n_monitors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protocol statistical informaition. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_rcvd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_sent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> idle_echo_xid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个虚拟的连接，具体连接又由 <strong>vconn-provider</strong> 提供，包括状态、版本、IP以及接收和发送的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Active virtual connection to an OpenFlow device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure should be treated as opaque by vconn implementations. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vconn_class</span> *<span class="title">class</span>;</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> min_version;</span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">bool</span> reconnectable;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_rcvd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_sent</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，总而言之可以把 remote 视为AP的安全信道。</p>
<p>在解析remote_run函数前，还要说明一个结构体：sender。sender由remote结构体和一个id组成，用以表示接收到的 OpenFlow 消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The origin of a received OpenFlow message, to enable sending a reply. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sender</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remote</span> *<span class="title">remote</span>;</span>      <span class="comment">/* The device that sent the message. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> xid;               <span class="comment">/* The OpenFlow transaction ID. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>remote_run</strong> 函数主要职责是保持安全信道运行并捕获由controller发来的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">remote_run(struct datapath *dp, struct remote *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    rconn_run(r-&gt;rconn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do some remote processing, but cap it at a reasonable amount so that</span></span><br><span class="line"><span class="comment">     * other processing doesn't starve. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!r-&gt;cb_dump) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *<span class="title">buffer</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ofp_header</span> *<span class="title">oh</span>;</span></span><br><span class="line"></span><br><span class="line">            buffer = rconn_recv(r-&gt;rconn);</span><br><span class="line">            <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buffer-&gt;size &gt;= <span class="keyword">sizeof</span> *oh) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sender</span> <span class="title">sender</span>;</span></span><br><span class="line"></span><br><span class="line">                oh = (struct ofp_header *)buffer-&gt;data;</span><br><span class="line">                sender.remote = r;</span><br><span class="line">                sender.xid = oh-&gt;xid;</span><br><span class="line">                fwd_control_input(dp, &amp;sender, buffer-&gt;data, buffer-&gt;size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                VLOG_WARN_RL(&amp;rl, <span class="string">"received too-short OpenFlow message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ofpbuf_delete(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;n_txq &lt; TXQ_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">int</span> error = r-&gt;cb_dump(dp, r-&gt;cb_aux);</span><br><span class="line">                <span class="keyword">if</span> (error &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                        VLOG_WARN_RL(&amp;rl, <span class="string">"dump callback error: %s"</span>,</span><br><span class="line">                                     strerror(-error));</span><br><span class="line">                    &#125;</span><br><span class="line">                    r-&gt;cb_done(r-&gt;cb_aux);</span><br><span class="line">                    r-&gt;cb_dump = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rconn_is_alive(r-&gt;rconn)) &#123;</span><br><span class="line">        remote_destroy(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>rconn_run 函数建立连接。</li>
<li>rconn_recv 接受连接中的数据包，并将数据包存储在 buffer 中。</li>
<li><strong>fwd_control_input</strong> 解析接收到的数据包并进行下一步操作。</li>
</ul>
<h4 id="fwd-control-input"><a href="#fwd-control-input" class="headerlink" title="fwd_control_input"></a>fwd<strong>_control_input</strong></h4><ul>
<li>从数据包的包头中提取数据，根据不同数据类型进行操作。</li>
<li>操作函数暂存在 <strong>handler</strong> 中。</li>
<li>具体的操作函数将在后续文章中逐个介绍。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 'msg', which is 'length' bytes long, was received from the control path.</span></span><br><span class="line"><span class="comment"> * Apply it to 'chain'. */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">fwd_control_input(struct datapath *dp, <span class="keyword">const</span> struct sender *sender,</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> (*handler)(struct datapath *, <span class="keyword">const</span> struct sender *, <span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofp_header</span> *<span class="title">oh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> min_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check encapsulated length. */</span></span><br><span class="line">    oh = (struct ofp_header *) msg;</span><br><span class="line">    <span class="keyword">if</span> (ntohs(oh-&gt;length) &gt; length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(oh-&gt;version == OFP_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Figure out how to handle it. */</span></span><br><span class="line">    <span class="keyword">switch</span> (oh-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> OFPT_BARRIER_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_barrier_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_FEATURES_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_features_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_GET_CONFIG_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_get_config_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_SET_CONFIG:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_switch_config);</span><br><span class="line">        handler = recv_set_config;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_PACKET_OUT:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_packet_out);</span><br><span class="line">        handler = recv_packet_out;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_FLOW_MOD:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_flow_mod);</span><br><span class="line">        handler = recv_flow;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_PORT_MOD:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_port_mod);</span><br><span class="line">        handler = recv_port_mod;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_STATS_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_stats_request);</span><br><span class="line">        handler = recv_stats_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_ECHO_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_echo_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_ECHO_REPLY:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_echo_reply;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_QUEUE_GET_CONFIG_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_queue_get_config_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_VENDOR:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_vendor_header);</span><br><span class="line">        handler = recv_vendor;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        dp_send_error_msg(dp, sender, OFPET_BAD_REQUEST, OFPBRC_BAD_TYPE,</span><br><span class="line">                          msg, length);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle it. */</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; min_size)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> handler(dp, sender, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后回到非常重要的函数 <strong>send_openflow_buffer</strong> ，此函数也在之前多次看到，现在我们来看一下它的具体代码。</p>
<h4 id="send-openflow-buffer"><a href="#send-openflow-buffer" class="headerlink" title="send_openflow_buffer"></a>send_openflow_buffer</h4><ul>
<li>函数首先判断是否为控制器发送来的数据，如果是，则sender不为零，执行第一个if操作，发送回去。</li>
<li>如果不是，解析目的端口，然后用 <strong>send_openflow_buffer_to_remote</strong> 把 buffer 发送到安全信道。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">send_openflow_buffer(struct datapath *dp, struct ofpbuf *buffer,</span><br><span class="line">                     <span class="keyword">const</span> struct sender *sender)</span><br><span class="line">&#123;</span><br><span class="line">    update_openflow_length(buffer);</span><br><span class="line">    <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">        <span class="comment">/* Send back to the sender. */</span></span><br><span class="line">        <span class="keyword">return</span> send_openflow_buffer_to_remote(buffer, sender-&gt;remote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Broadcast to all remotes. */</span></span><br><span class="line">        struct remote *r, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        LIST_FOR_EACH (r, struct remote, node, &amp;dp-&gt;remotes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">                <span class="comment">//send_openflow_buffer_to_remote(ofpbuf_clone(buffer), prev);</span></span><br><span class="line">                send_openflow_buffer_to_remote(buffer, prev);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">            send_openflow_buffer_to_remote(buffer, prev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ofpbuf_delete(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="send-openflow-buffer-to-remote"><a href="#send-openflow-buffer-to-remote" class="headerlink" title="send_openflow_buffer_to_remote"></a>send_openflow_buffer_to_remote</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_openflow_buffer_to_remote(struct ofpbuf *buffer, struct remote *remote)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = rconn_send_with_limit(remote-&gt;rconn, buffer, &amp;remote-&gt;n_txq,</span><br><span class="line">                                       TXQ_LIMIT);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        VLOG_WARN_RL(&amp;rl, <span class="string">"send to %s failed: %s"</span>,</span><br><span class="line">                     rconn_get_name(remote-&gt;rconn), strerror(retval));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sends 'b' on 'rc'.  Increments '*n_queued' while the packet is in flight; it</span></span><br><span class="line"><span class="comment"> * will be decremented when it has been sent (or discarded due to</span></span><br><span class="line"><span class="comment"> * disconnection).  Returns 0 if successful, EAGAIN if '*n_queued' is already</span></span><br><span class="line"><span class="comment"> * at least as large as 'queue_limit', or ENOTCONN if 'rc' is not currently</span></span><br><span class="line"><span class="comment"> * connected.  Regardless of return value, 'b' is destroyed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because 'b' may be sent (or discarded) before this function returns, the</span></span><br><span class="line"><span class="comment"> * caller may not be able to observe any change in '*n_queued'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is no rconn_send_wait() function: an rconn has a send queue that it</span></span><br><span class="line"><span class="comment"> * takes care of sending if you call rconn_run(), which will have the side</span></span><br><span class="line"><span class="comment"> * effect of waking up poll_block(). */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">rconn_send_with_limit(struct rconn *rc, struct ofpbuf *b,</span><br><span class="line">                      <span class="keyword">int</span> *n_queued, <span class="keyword">int</span> queue_limit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    retval = *n_queued &gt;= queue_limit ? EAGAIN : rconn_send(rc, b, n_queued);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        ofpbuf_delete(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几段代码比较简单，不过多说明，总之就是通过 <strong>rconn_send</strong> 发送到安全信道中。</p>
<p>因为是主函数直接调用的函数，总体还是框架性的函数。其他功能性函数将在接下里的文章中介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/06/16/post5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/post5/" itemprop="url">Open VSwitch in OpenWrt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-16T17:31:58+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在这一篇博客中，我将详细介绍如何在OpenWrt系统中搭建Open VSwitch，从而让AP适用于SDN系统。</p>
<p>AP有“瘦AP”（<strong>Fit AP</strong>）和“胖AP”（<strong>Fat AP</strong>）之分，Fat AP是与Fit AP相对来讲的，Fat AP将WLAN的物理层、用户数据加密认证、QoS、网络管理、漫游技术以及其他应用层的功能集于一身。Fat AP无线网络解决方案可由由Fat AP直接在有线网的基础上构成，设备结构复杂，且难于集中管理，比较常用于家庭无线接入，即所谓的“无线路由器”。Fit AP是一个只有加密、射频功能的AP，功能单一，不能独立工作。整个Fit AP无线网络解决方案由无线控制器和Fit AP在有线网的基础上构成。Fit AP上“零配置”，所有配置都集中到无线控制器上。这也促成了Fit AP解决方案更加便于集中管理，并由此具有三层漫游、基于用户下发权限等Fat AP不具备的功能。</p>
<p>本文的解决方案为Fat AP的SDN适配方案，解决思路为<strong>Fat AP + Openwrt + OVS</strong>。我将介绍三种在Openwrt下安装OVS的方法。</p>
<center><font size="10">Install OpenVSwitch in OpenWrt</font></center>

<hr>
<h3 id="方法一-编译一个带Open-VSwitch版本的OpenWrt固件"><a href="#方法一-编译一个带Open-VSwitch版本的OpenWrt固件" class="headerlink" title="方法一  编译一个带Open VSwitch版本的OpenWrt固件"></a>方法一  编译一个带Open VSwitch版本的OpenWrt固件</h3><p>这种方法是在Linux系统下直接编译一个带有Open VSwitch的固件，并将固件刷入AP中。</p>
<p>此方法操作步骤简单，但容易出错，编译过程常伴随各种未知错误。本人尝试过多次，编译过多种版本下的固件，失败多过成功。但这种方法还是推荐大家学习，方便日后进一步学习扩展。</p>
<ul>
<li><p>升级软件安装包，安装编译时需要的组件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gccg++binutilspatchbzip2flexbison make autoconf gettext texinfo unzip sharutils subversion libncurses5-devncurses-term zlib1g-dev subversion git gawk asciidoc libz-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取OpenWrt源码并添加OVS</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.openwrt.org/openwrt.git <span class="comment">#获取Openwrt源码</span></span><br><span class="line"><span class="built_in">cd</span> openwrt</span><br><span class="line">./scripts/feeds update –a <span class="comment">#更新最新代码</span></span><br><span class="line">./scripts/feeds install –a <span class="comment">#安装最新组件</span></span><br><span class="line">svn up <span class="comment">#更新版本号</span></span><br><span class="line"><span class="comment">#添加openwrt代码连接</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'src-git openvswitch git://github.com/pichuang/openvwrt.git'</span> &gt;&gt; feeds.conf </span><br><span class="line"><span class="comment">#或者（建立代码连接）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'src-git openvswitch git://github.com/ttsubo/openvswitch.git'</span> &gt;&gt; feeds.conf </span><br><span class="line"></span><br><span class="line">./scripts/feeds update openvswitch </span><br><span class="line">./scripts/feeds install -a -p openvswitch</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译固件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1 选择CPU型号（根据AP硬件选择，可参见openwrt的wiki页面）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target System—–Atheros AR71xx/AR7240/AR913x/AR934x</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 选择路由型号（根据路由器型号选择）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TargetProfile—-xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 添加 Luci 及相关组件（语言包+DNNS）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LuCI—&gt;Collections—–&lt;*&gt; luci</span><br><span class="line">LuCI—&gt;Translations—-&lt;*&gt; luci-i18n-chinese</span><br><span class="line">LuCI—&gt;Applications —&gt; &lt;*&gt;luci-app-ddns.</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 添加UTF8编码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel modules —&gt; Native Language Support —&gt; &lt;*&gt; kmod-nls-utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>5  添加复位键支持</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Utilities —&gt; &lt;*&gt; restorefactory</span><br></pre></td></tr></table></figure>
</li>
<li><p>6 添加 openvswitch</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Network -&gt; openvswitch-switch, openvswitch-switch, openvswitch-ipsec (Optional)</span><br></pre></td></tr></table></figure>
</li>
<li><p>7 save</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=99</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>固件编译成功后将在 target 文件夹中找到 .bin 文件，然后将镜像文件刷进系统，就得到了一个有Open VSwitch的AP。</p>
<h3 id="方法二-通过opkg安装Open-Vswitch"><a href="#方法二-通过opkg安装Open-Vswitch" class="headerlink" title="方法二 通过opkg安装Open Vswitch"></a>方法二 通过opkg安装Open Vswitch</h3><p>这种方法是利用Openwrt系统本身的<strong>opkg</strong>(Open PacKaGe management)管理器直接从互联网下载OVS的安装文件和相关依赖。</p>
<p>此方法有个前提是必须保证AP本身可以上网。</p>
<p>####AP连入互联网</p>
<p>Openwrt系统的官方固件中的WAN是默认DPCH上网的，最简单的上网方式是连接到上级网络的路由器：<strong>用网线连接此AP的WAN口和可上网的路由器的LAN口</strong>。这样Openwrt可以直接通过DPCH方式上网，不需要任何配置。</p>
<p>如果没有一个正常上网的路由器，AP联网的方式和其他商用路由器类似。首先将AP的WAN口连接到墙上的网口，打开luci界面：<strong>192.168.1.1</strong>，选择接口(interfaces)，编辑WAN，然后按照运营商的上网方式设置相对的上网协议，输入账号密码等。</p>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ul>
<li><p>打开<strong>SecureCRT</strong>用SSH协议连接到Openwrt（ip地址：192.168.1.1，具体方式可参见上一篇博客）。</p>
</li>
<li><p>更新安装包并安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opkg update -a</span><br><span class="line">opkg install kmod-openvswitch</span><br><span class="line">opkg install openvswitch</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我在使用这个方法安装时，一直出现无法连接到官方下载网站的问题。无法完成更新，也无法安装。</p>
<h3 id="方法三-使用ipk安装包安装"><a href="#方法三-使用ipk安装包安装" class="headerlink" title="方法三  使用ipk安装包安装"></a>方法三  使用ipk安装包安装</h3><p>第三种方法是我自己发现的方法，优点是简单而且不容易出错，但缺点就是太麻烦。如果走投无路了，也可以尝试一下这个方法。</p>
<p>此方法就是在Openwrt的软件库上下载相对应的安装包，放入Openwrt的 <strong>/tmp/</strong>文件夹内，利用<strong>opkg install</strong>命令安装。</p>
<ul>
<li><p>在openwrt的<a href="https://archive.openwrt.org/" target="_blank" rel="noopener">archive</a>网站找到对应的Openwrt固件版本</p>
<p><a href="https://archive.openwrt.org/attitude_adjustment" target="_blank" rel="noopener">attitude_adjustment</a>            v12.09</p>
<p><a href="https://archive.openwrt.org/backfire" target="_blank" rel="noopener">backfire</a>                        v10.03 / v10.03.1</p>
<p><a href="https://archive.openwrt.org/barrier_breaker" target="_blank" rel="noopener">barrier_breaker</a>                v14.07</p>
<p><a href="https://archive.openwrt.org/chaos_calmer" target="_blank" rel="noopener">chaos_calmer</a>                v15.05 / v15.05.1</p>
<p><a href="https://archive.openwrt.org/releases" target="_blank" rel="noopener">releases</a>                        v17.01.0 - v17.01.4</p>
<p><a href="https://archive.openwrt.org/snapshots" target="_blank" rel="noopener">snapshots</a>                    trunk</p>
</li>
<li><p>进入分类和版本内，选择相应文件系统，普遍是<strong>ar71xx</strong>。</p>
</li>
<li><p>选择 <strong>genetic/</strong>文件夹</p>
</li>
<li><p>选择<strong>Supplementary Files</strong>中的<strong>packages</strong>。</p>
</li>
<li><p><strong>packages</strong>文件夹中有六个文件夹，所有的ipk文件都在这六个文件夹中。</p>
<p>​    base/                    Openwrt系统工具（大部分工具安装包可在其中找到）</p>
<p>​    luci/                    luci相关</p>
<p>​    management/            管理包（不常用）</p>
<p>​    packages/                工具和其他依赖文件</p>
<p>​    routing/                    不常用</p>
<p>​    telephony/                不常用</p>
<p>大部分的基础工具都可以在 <strong>base/</strong> 文件夹中找到，所需的依赖文件可在 <strong>packages/</strong> 中找到。</p>
</li>
<li><p>在<strong>packages/</strong>文件夹中，用ctrl+F搜索 openvswitch ，下载以下ipk文件：</p>
<p>​    openvswitch_xx.xx.xx (xx是版本号)</p>
<p>​    openvswitch-benchmark_xx.xx.xx</p>
<p>​    kmod_openvswitch_xx.xx.xx</p>
</li>
<li><p>打开<strong>SecureCRT</strong>软件和<strong>WinSCP</strong>软件，连接到AP。</p>
</li>
<li><p>用<strong>WinSCP</strong>将ipk文件导入到 Openwrt 系统的 <strong>/tmp/</strong> 文件夹下。</p>
</li>
<li><p>在<strong>SecureCRT</strong>中输入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">opkg install openvswitch_xx.xx.xx.ipk <span class="comment">#正确文件名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装一定会失败，并提示<strong>缺少以下依赖</strong>，此时，在archive文件夹中根据错误提示逐个寻找依赖的ipk文件包，用同样的方式进行安装。</p>
</li>
<li><p>安装完所有缺省再次安装openvswitch的ipk。</p>
</li>
<li><p>安装ovs时，如果出现内核版本不对的错误提示，但又确实是安装了同一个CPU版本下的ovs包，可以尝试强制安装，如果安装之后可以使用ovs，就没有问题。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg --force-depends install openvswitch_xx.xx.xx.ipk</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法确实非常麻烦，但是成功率很高，同时也适用于安装其他类型的工具包，所以比较推荐。</p>
<hr>
<p>以上是我总结的三种在openwrt上安装openvswitch的方法，下一篇我讲继续介绍ovs的相关配置和使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/05/29/post4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/29/post4/" itemprop="url">Start With OpenWrt /3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-29T17:42:28+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> Start with OpenWrt /3</p>
<h2 id="终极刷机——TTL法"><a href="#终极刷机——TTL法" class="headerlink" title="终极刷机——TTL法"></a>终极刷机——TTL法</h2><hr>
<p>TTL刷机就是指用TTL线（串口线）让路由器与电脑的BOOT进行串口通信，然后通过网口利用TFTP把固件传输过来。</p>
<p>所以这种方法同样适合在路由器死机变砖了之后救活它。</p>
<p>引用一个<a href="https://blog.csdn.net/xcoderone/article/details/48030771" target="_blank" rel="noopener">滑冰犀鸟</a>的原理解释：</p>
<blockquote>
<h3 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h3><ul>
<li>TTL线就是串口线（USB转串口）。</li>
<li>系统固件不是通过TTL线传输到路由器中。</li>
<li>TTL线的作用是让PC端和BOOT进行串口通信。</li>
<li>PC端通过串口线使用BOOT的控制台。</li>
<li>系统固件实际是通过网口（TFTP协议）传输到路由器中。</li>
</ul>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>TTL刷机需要进行一些焊接工作，提前准备好<strong>电烙铁，排针，杜邦线</strong>等电工工具。</p>
</li>
<li><p><strong>TTL转USB线</strong>，可以在淘宝买到，但是一定要买对型号，具体可参考wiki或询问淘宝客服。</p>
</li>
<li><p>网线</p>
</li>
<li><p>Windows上安装SecureCRT、Putty、Tftpd(注意选择32位/64位)。</p>
</li>
</ul>
<h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>首先，在OpenWrt的wiki页面找到相应型号路由器的电路板图片。以TP-LINK 841n为例，它的<a href="https://wiki.openwrt.org/toh/tp-link/tl-wr841nd" target="_blank" rel="noopener">wiki</a>页面下有一个<strong>Serial port settings:</strong>栏，在其中你可以找到电路板上GND RX TX在哪（一般都不会使用到VCC，但具体还是要根据路由器型号判断）。</p>
<p><img src="https://wiki.openwrt.org/_media/media/tplink/tl-wr841/tl-wr841n-v7.2_serial-pinout.jpg?cache=" alt="hardware"></p>
<p>然后，将GND口、TX和RX焊上排针，再用杜邦线连接出来。</p>
<p><strong>TTL转USB线</strong>比较推荐如图这样的，无须再焊接，把从排针印出来的杜邦线接上就可以了。需要注意的是，购买转串口线的时候一定要注意型号，在wiki看好型号再去找，买的时候也要多和卖家沟通，否则会出现扫码率怎么都对不上等乱七八糟的问题。</p>
<p><img src="https://www.icshop.com.tw/images/product_images/original_images/22215_0.gif" alt="杜邦线"></p>
<p>接着，将电路板引出来的TX接到串口线的RX，RX接到TX，GND接GND，电路方面的准备工作理论上就完成了。</p>
<h3 id="正式刷机"><a href="#正式刷机" class="headerlink" title="正式刷机"></a>正式刷机</h3><ul>
<li>设置电脑ip设置到与路由器相同网段，如：192.168.1.169</li>
<li>打开<strong>SecureCRT</strong>，按照如下设置并连接。</li>
</ul>
<p>​    protol: <strong>Serial</strong></p>
<p>​    port: <strong>COMx</strong> （在电脑的<strong>设备管理器</strong>中查看端口号）</p>
<p>​    Baud rate: <strong>115200</strong>（通常是这个速率，但具体值根据型号不同有所不同）</p>
<p>​    Data bits: <strong>8</strong></p>
<p>​    Parity: <strong>None</strong></p>
<p>​    Stop bits: <strong>1</strong></p>
<p>​    Flow Control: <strong>均不钩选</strong></p>
<p>​    </p>
<ul>
<li><p>将电脑的无线网卡禁用，如果电脑有多张有线网卡也将其他几张禁用，关闭防火墙。</p>
</li>
<li><p>把官方固件（openwrt-ar71xx-generic-tl-wr841nd-v7-squashfs-factory.bin</p>
<p>）与<strong>Tftpd32</strong>放在同一个文件夹中（官方固件的获取方式在上两篇文章中有介绍），打开tftpd。</p>
</li>
<li><p>将USB串口连接到电脑，为路由器通电，<strong>WAN</strong>口用网线与电脑网口相连，在SecureCRT中可以看到开机信息，则证明串口连接成功。</p>
<p>如果出现乱码，应该是Baud rate设置有误；如果没有反应，但路由器灯正常亮起，则可能是电路出了问题。</p>
</li>
<li><p>将路由器断电，重新通电，在SecureCRT上查看打印信息，出现</p>
<blockquote>
<p>Autobooting in 1s…</p>
</blockquote>
<p>马上在键盘上按下tpl（也有一些路由器需要按Ctrl+c 或者其他，具体可以参照特定路由器的刷机教程）</p>
</li>
<li><p>成功进入路由器系统的boot界面。</p>
</li>
<li><p>在窗口输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.1</span><br><span class="line">setenv serverip 192.168.1.169</span><br></pre></td></tr></table></figure>
<p>​    ipaddr 是路由器的ip地址</p>
<p>​    serverip是电脑的ip地址</p>
</li>
<li><p>将固件拷到路由器内存中，0x80000000是flash上一段空白位置，可以暂时存储文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ar7240&gt; tftpboot 0x80000000 openwrt-ar71xx-generic-tl-wr841n-v8-squashfs-factory.bin</span><br><span class="line">Using eth0 device</span><br><span class="line">TFTP from server 192.168.1.100; our IP address is 192.168.1.111</span><br><span class="line">Filename <span class="string">'openwrt-ar71xx-generic-tl-wr841n-v8-squashfs-factory.bin'</span>.</span><br><span class="line">Load address: 0x80000000</span><br><span class="line">Loading: checksum bad</span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">#################################################################</span></span><br><span class="line">         <span class="comment">######################################################</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Bytes transferred = 3932160 (3c0000 hex)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将flash原来的固件文件擦除</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar7240&gt; erase 0x9f020000 +0x3c0000</span><br></pre></td></tr></table></figure>
<p>0x9f020000为内核的启动地址，在<strong>开机的引导信息</strong>中可以看到，见840N的U-boot行 </p>
<blockquote>
<p>Booting image at 9f020000 …</p>
</blockquote>
<p> 不同的路由器启动地址也有所不同，具体情况可以在uboot行中看到。 </p>
<p>0x3c0000为固件大小，这个输错了路由器会变砖，上一步返回信息的最后一句会给出。</p>
</li>
<li><p>擦除完成后，将openwrt固件复制到固件启动地址中，bootm启动。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar7240&gt; cp.b 0x80000000 0x9f020000 0x3c0000</span><br><span class="line">ar7240&gt; bootm 0x9f020000</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后，系统就开始重新启动了，将计算机网线接入LAN口，完成刷机啦。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>特别说明，这里的刷机过程是以TP-LINK TL-WR841N为例的，其他型号可能在细节上需要稍作改动，但具体都可以参考<a href="http://wiki.openwrt.org/toh/start#tp-link" target="_blank" rel="noopener">Openwrt wiki</a>，当然，这句话也是经常出现在我的教程里，就是去wiki页面参考。虽然wiki是英文版面，有时候大家看起来会有点吃力而遗漏很多细节，但是其中真的包罗万象，几乎能解决你所有遇到的问题。所以在wiki中好好探索吧。</p>
<p>虽然想写一个适用于新手的教程，但是写下来才发现，其实每个人遇到的问题都是不一样的，而我也只能主要强调我踩过的坑。所以也许也不是那么适合所有人，这一点真的非常遗憾。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/05/13/post3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/post3/" itemprop="url">Start With OpenWrt /2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-13T10:19:21+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> Start With OpenWrt /2</p>
<h2 id="刷机进阶——TFTP法"><a href="#刷机进阶——TFTP法" class="headerlink" title="刷机进阶——TFTP法"></a>刷机进阶——TFTP法</h2><p>这两种方式在Openwrt的wiki页面应该都有很详细的指导教程，我的经验是，如果你找到了一个自认为靠谱的教程，也记得先看看wiki上的介绍，有个大致的概念和对错判断。如果两者有出入，基本还是以wiki为准的。</p>
<hr>
<h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><p>用TFTP方式刷机的原理其实和网页版本差不多，有一些版本的路由器甚至要挂载TFTP服务器才能完成固件更新。我的理解来说，TFTP的好处就在于有时候可能可以跨过网页版运营商对非官方固件的屏蔽，比较粗暴得导入固件。</p>
<p>用TFTP的方式，个人推荐是在<strong>Linux</strong>系统下进行，命令行输入、启动tftp服务器什么的会更方便。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>1.安装并启动<strong>TFTP服务器(TFTP Server)</strong>，注意将<strong>TFTP固件</strong>放在home(host)文件夹下，因为用tftp传输时，固件前不能添加路径。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tftpd-hpa tftp</span><br><span class="line">sudo cp ~/uboot/arch/arm/boot/uboot.img /var/lib/tftpboot</span><br></pre></td></tr></table></figure>
<ul>
<li>2.将固件重命名为简单形式，如 <strong>a1.bin</strong>。（这一步可有可无，仅仅为了方便接下来的命令行输入）</li>
<li>3.TFTP传输过程中必须保证网络链接在路由器开启电源时就建立，为保重这一步成功，可以先关闭网络。(根据你linux系统的版本从以下选择合适的命令行)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/networking stop</span><br><span class="line">/etc/init.d/network stop</span><br><span class="line">/etc/init.d/NetworkManager stop</span><br><span class="line">service networking stop</span><br><span class="line">service network stop</span><br><span class="line">service NetworkManager stop</span><br></pre></td></tr></table></figure>
<ul>
<li>4.配置与引导程序相匹配的静态IP地址。（一般为192.168.1.1，可以从路由器wiki页面中找到相关信息）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 ipv4.x.y.z netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<ul>
<li>5.为TFTP预置arp请求条目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arp -s ipv4.x.y.1 20:aa:bb:cc:dd:00</span><br><span class="line"><span class="meta">#</span><span class="bash">ipv4.x.y.1 是路由器ip地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20:aa:bb:cc:dd:00 是路由器背面的MAC地址</span></span><br></pre></td></tr></table></figure>
<h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>做完以上准备工作可以正式开始了。用<strong>TFTP客户端(TFTP Client)</strong>将固件上传路由器的基本方法如下：</p>
<ul>
<li>1.断开路由器电源</li>
<li>2.用网线将电脑与路由器<strong>LAN</strong>口相连</li>
<li><p>3.在电脑上启动<strong>TFTP客户端</strong></p>
</li>
<li><p>4.TFTP到路由器的<strong>ip地址</strong>(可在wiki页面查询)</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tftp IPv4.x.y.z</span><br><span class="line"><span class="meta">#</span><span class="bash">IPv4.x.y.z 为路由器的ip地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>5.设置TFTP传输模式为<strong>octet/binary</strong>(二进制传输)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">tftp&gt;</span><span class="bash"> binary </span></span><br><span class="line"><span class="meta">tftp&gt;</span><span class="bash"> rexmt 1 <span class="comment">#传输间隔为1秒</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>6.设置TFTP重传直至成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">tftp&gt;</span><span class="bash"> timeout 60</span></span><br><span class="line"><span class="meta">tftp&gt;</span><span class="bash"> trace</span></span><br><span class="line"><span class="meta">tftp&gt;</span><span class="bash"> Packet tracing on.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>7.用put命令设置传输的固件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">tftp&gt;</span><span class="bash"> put openwrt-xxx-x.x-xxx.bin</span></span><br></pre></td></tr></table></figure>
<ul>
<li>8.TFTP客户端开始工作的<strong>同时</strong>打开路由器电源</li>
<li>9.路由器大概需要<strong>十多秒</strong>才会成功启动，再次之前TFTP客户端持续发送请求。检测到路由器后，TFTP客户端将开始发送固件。</li>
<li>10.等待传输完成，路由器重启。</li>
</ul>
<h3 id="TFTP方式的其他命令行形式实现"><a href="#TFTP方式的其他命令行形式实现" class="headerlink" title="TFTP方式的其他命令行形式实现"></a>TFTP方式的其他命令行形式实现</h3><h4 id="aTFTP"><a href="#aTFTP" class="headerlink" title="aTFTP"></a>aTFTP</h4><ul>
<li>一条命令行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atftp --trace --option "timeout 1" --option "mode octet" --put --local-file openwrt-xxx-x.x-xxx.bin IPv4.x.y.z</span><br></pre></td></tr></table></figure>
<p>​    <em> <strong>按下回车的同时接通路由器电源</strong> </em></p>
<ul>
<li>分布命令行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">atftp</span><br><span class="line">connect IPv4.x.y.z</span><br><span class="line">mode octet</span><br><span class="line">trace</span><br><span class="line">timeout 1</span><br><span class="line">put openwrt-xxx-x.x-xxx.bin</span><br></pre></td></tr></table></figure>
<h4 id="Netkit’s-TFTP"><a href="#Netkit’s-TFTP" class="headerlink" title="Netkit’s TFTP"></a>Netkit’s TFTP</h4><ul>
<li>一条命令行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "binary\nrexmt 1\ntimeout 60\ntrace\nput openwrt-xxx-x.x-xxx.bin\n" | tftp IPv4.x.y.z</span><br></pre></td></tr></table></figure>
<ul>
<li>分布命令行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tftp IPv4.x.y.z</span><br><span class="line">tftp&gt; binary</span><br><span class="line">tftp&gt; rexmt 1</span><br><span class="line">tftp&gt; timeout 60</span><br><span class="line">tftp&gt; trace</span><br><span class="line">tftp&gt; Packet tracing on.</span><br><span class="line">tftp&gt; put openwrt-xxx-x.x-xxx.bin</span><br></pre></td></tr></table></figure>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -T openwrt-xxx-x.x-xxx.bin tftp://IPv4.x.y.z</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Tips总结"><a href="#Tips总结" class="headerlink" title="Tips总结"></a>Tips总结</h3><p>用TFTP的方式有几个需要特别注意的点：</p>
<ul>
<li>一定要将固件放在home文件夹下，因为tftp put 的时候只添加文件名，不能前置文件路径。</li>
<li>开始tftp传输的<strong>同时</strong>接通电源</li>
<li>主机的ip地址要与路由器的ip地址在一个子网下，所以不要忘记提前把网络模式从DHCP改成Static。</li>
</ul>
<p>希望这篇能够帮助到你，用tftp方式刷机总体来说实现难度不大，但是一定要细心，不要遗漏任何步骤。遇到问题可以详见OpenWrt的Wiki页面，基本都有详细的教程。同时也欢迎通过Email联系我。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/05/12/post2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/post2/" itemprop="url">Start With OpenWrt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T12:53:08+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> Start With OpenWrt</p>
<h2 id="从挑选路由器到刷机"><a href="#从挑选路由器到刷机" class="headerlink" title="从挑选路由器到刷机"></a>从挑选路由器到刷机</h2><p>不管你的用途是什么，只要涉及自定义路由器，<a href="https://openwrt.org/" target="_blank" rel="noopener">Openwrt</a>是最常用也最好用的开源系统。把一款商用路由器刷成Openwrt路由器，其实就是更改路由器的固件——将路由器默认的固件（.bin）文件替换。那么如何将市面上买的商用路由器刷成Openwrt系统呢？第一步要做的，是先选择一款路由器。</p>
<hr>
<h3 id="选择路由器"><a href="#选择路由器" class="headerlink" title="选择路由器"></a>选择路由器</h3><p>首先，选择路由器基本可以遵循以下步骤：</p>
<ul>
<li>选择一个路由器<strong>品牌(Brand)</strong>（D-Link，TP-Link等），在网上查询现有售卖的<strong>型号(Model)</strong>。</li>
<li>在Openwrt的<a href="https://wiki.openwrt.org/toh/start" target="_blank" rel="noopener">wiki</a>页面上选择品牌和型号，与市面上还能买到的路由器对应查看，选择一款能够买到的。</li>
<li>进入对应路由器wiki页面，查看Openwrt官方固件出的<strong>版本号(Version)</strong>。</li>
<li>向卖家确认路由器版本号。</li>
</ul>
<p>到这里都没有碰壁，只能说你非常幸运。因为通过正规渠道有售的路由器在Openwrt上能找到的就已经不多，其次即使找到了相同的型号，市面上的路由器版本也往往太新，而Openwrt没有release新版本的固件。</p>
<p>这里需要特别注意的是，旧版本一般不能适配新版本，虽然他们的型号一样，但是不同版本之间的硬件设置不同。而且，同一个版本的海内外产品也有区别。</p>
<p>还要说明的是，OpenWrt是国外的平台，而路由器厂商针对中国市场和海外市场对同一款路由器有不同版本的配置。一般而言，海外版本的路由器更适合搭载Openwrt系统，因为他们往往拥有更大的Flash内存。国内的新路由器一般只配置4M的Flash内存（有的甚至只有2M），基本只够勉强塞入固件系统（3.8M），更别提承载其他配置。</p>
<p>所以我的经验是，通过正规渠道一般已经没有办法购买到合适的路由器了，就算真的购买到了，后续可能也需要对路由器的Flash和RAM进行扩容。嫌麻烦的人其实可以直接上淘宝买个改装好的路由器，有工程追求的人请参见以下几篇硬改教程：</p>
<ul>
<li><a href="https://blog.csdn.net/aggresss/article/details/52753098" target="_blank" rel="noopener">aggresss的专栏</a></li>
<li><a href="https://my.oschina.net/osbin/blog/282141" target="_blank" rel="noopener">TP-LINK 845N V1硬改</a></li>
<li><a href="https://blog.csdn.net/flyingcys/article/details/54671532" target="_blank" rel="noopener">TP-LINK_841N_V8路由器</a> （好文！）</li>
</ul>
<hr>
<h3 id="路由器刷机"><a href="#路由器刷机" class="headerlink" title="路由器刷机"></a>路由器刷机</h3><p>现在，你有了一个可以刷Openwrt官方固件的路由器，但是我们默认路由器内置的固件还是运营商提供的。所以这一步讲的是如何将固件刷成Openwrt，难度从低到高有三种：</p>
<ul>
<li>网页法</li>
<li>TFTP法</li>
<li>TTL法</li>
</ul>
<p>在开始刷机之前，要先对路由器的结构有个基本的认识。路由器上的网线接口一般有1个WAN口，和多个LAN口，一般有不同的颜色和标识。</p>
<p><img src="/blog/source/_posts/post2/Screen Shot 2018-05-12 at 12.41.04 PM.png" alt="路由器网口标识"></p>
<p>除此之外，还有一个电源接口和一个小小的reset孔（一般而言reset孔在里面，要用牙签或者针头戳进去）。</p>
<h4 id="网页法"><a href="#网页法" class="headerlink" title="网页法"></a>网页法</h4><p>首先在路由器的Openwrt Wiki 页面里找到官方的release版本，下载到本地。注意区分Install Image和Update Image，这里我们选择Install Image，文件后缀是<strong>squashfs-factory.bin</strong>。</p>
<p><img src="/blog/source/_posts/post2/20140417175607_4955.png" alt="下载镜像和更新镜像"></p>
<p>然后，将路由器断电，将LAN1口用网线与电脑连接，然后摁住reset按钮，同时接通电源。</p>
<p>观察路由器的亮灯情况，一般要维持10s左右，亮灯状态维持稳定时，松开reset按钮。因为不同的路由器亮灯情况不同，如果不放心可以直接搜索 路由器型号+刷机 ，找到教程看具体的状态。</p>
<p>从路由器背面查看ip地址，一般为：192.168.1.1，从网页输入ip地址登录。（账号密码信息也会在路由器背面贴出，一般默认是 admin ，如果没有可以上路由器官网查看。）</p>
<p>进入页面后，选择软件升级，然后添加刚刚下载的 <strong>.bin</strong> 文件，点击更新即可。<strong>注意过程中保持电源通电，等待路由器重启成功。</strong> </p>
<p>通过网页的方式非常简单，但是也经常失败，如果不成功可以尝试：</p>
<ul>
<li>关闭电脑防火墙</li>
<li>查看版本号是否对应</li>
</ul>
<p>路由器运营商也可能会针对网页刷机做一些屏蔽，所以网页刷机往往成功率不高。如果失败了，可以继续尝试用TFTP方式甚至TTL方式刷机。具体方法，请参加以下两篇。</p>
<h4 id="TFTP法"><a href="#TFTP法" class="headerlink" title="TFTP法"></a><a href="https://fantinyang.github.io/2018/05/13/post3/">TFTP法</a></h4><h4 id="TTL法"><a href="#TTL法" class="headerlink" title="TTL法"></a><a href="">TTL法</a></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Fantin" />
          <p class="site-author-name" itemprop="name">Fantin</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/FantinYang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="yangfan.gm@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-e-mail"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yangfantin" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/y526147723/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fantin</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
