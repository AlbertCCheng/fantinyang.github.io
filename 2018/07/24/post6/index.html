<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="OpenFlow," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="openflow1.0.0 是斯坦福团队在2008年为满足AP在SDN系统中适配提出的openflow协议无线域扩展。此协议以openflow1.0为基础，解析处理 ieee80211 数据；利用 click 元素实现AP到控制器的转发功能。 这一篇文章从主函数出发，解读了代码的几个框架性函数。 主程序运行在 udatapath.c 中。 从 main 函数开始解读&amp;gt;   123456789">
<meta name="keywords" content="OpenFlow">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenFlow1.0.0 带无线扩展的OF1.0协议代码详解———main">
<meta property="og:url" content="https://fantinyang.github.io/2018/07/24/post6/index.html">
<meta property="og:site_name" content="FantinOcean">
<meta property="og:description" content="openflow1.0.0 是斯坦福团队在2008年为满足AP在SDN系统中适配提出的openflow协议无线域扩展。此协议以openflow1.0为基础，解析处理 ieee80211 数据；利用 click 元素实现AP到控制器的转发功能。 这一篇文章从主函数出发，解读了代码的几个框架性函数。 主程序运行在 udatapath.c 中。 从 main 函数开始解读&amp;gt;   123456789">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-24T06:59:14.732Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenFlow1.0.0 带无线扩展的OF1.0协议代码详解———main">
<meta name="twitter:description" content="openflow1.0.0 是斯坦福团队在2008年为满足AP在SDN系统中适配提出的openflow协议无线域扩展。此协议以openflow1.0为基础，解析处理 ieee80211 数据；利用 click 元素实现AP到控制器的转发功能。 这一篇文章从主函数出发，解读了代码的几个框架性函数。 主程序运行在 udatapath.c 中。 从 main 函数开始解读&amp;gt;   123456789">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fantinyang.github.io/2018/07/24/post6/"/>





  <title>OpenFlow1.0.0 带无线扩展的OF1.0协议代码详解———main | FantinOcean</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FantinOcean</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Share</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fantinyang.github.io/2018/07/24/post6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fantin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FantinOcean">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OpenFlow1.0.0 带无线扩展的OF1.0协议代码详解———main</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-24T09:19:39+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>openflow1.0.0</strong> 是斯坦福团队在2008年为满足AP在SDN系统中适配提出的openflow协议无线域扩展。此协议以openflow1.0为基础，解析处理 ieee80211 数据；利用 click 元素实现AP到控制器的转发功能。</p>
<p>这一篇文章从主函数出发，解读了代码的几个框架性函数。</p>
<p>主程序运行在 <strong>udatapath.c</strong> 中。</p>
<center><font size="8">从 main 函数开始解读</font>&gt;</center>

 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n_listeners;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    set_program_name(argv[<span class="number">0</span>]);  <span class="comment">//设置程序名</span></span><br><span class="line">    register_fault_handlers();  <span class="comment">//注册新号故障处理器</span></span><br><span class="line">    time_init();</span><br><span class="line">    vlog_init();</span><br><span class="line">    parse_options(argc, argv);  <span class="comment">//解析选项</span></span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>主要看一下 <strong>parse_options</strong> 函数，此函数定义了该子程序的解析选项。</p>
<h3 id="parse-options"><a href="#parse-options" class="headerlink" title="parse_options"></a>parse_options</h3><p>这里不是完整的函数代码，我们主要关注参数选项和对应的执行函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">parse_options(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] = &#123;</span></span><br><span class="line">        &#123;<span class="string">"interfaces"</span>,  required_argument, <span class="number">0</span>, <span class="string">'i'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"local-port"</span>,  required_argument, <span class="number">0</span>, <span class="string">'L'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"no-local-port"</span>, no_argument, <span class="number">0</span>, OPT_NO_LOCAL_PORT&#125;,</span><br><span class="line">        &#123;<span class="string">"datapath-id"</span>, required_argument, <span class="number">0</span>, <span class="string">'d'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"verbose"</span>,     optional_argument, <span class="number">0</span>, <span class="string">'v'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"help"</span>,        no_argument, <span class="number">0</span>, <span class="string">'h'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"version"</span>,     no_argument, <span class="number">0</span>, <span class="string">'V'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"no-slicing"</span>,  no_argument, <span class="number">0</span>, OPT_NO_SLICING&#125;,</span><br><span class="line">        &#123;<span class="string">"mfr-desc"</span>,    required_argument, <span class="number">0</span>, OPT_MFR_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"hw-desc"</span>,     required_argument, <span class="number">0</span>, OPT_HW_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"sw-desc"</span>,     required_argument, <span class="number">0</span>, OPT_SW_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"dp_desc"</span>,  required_argument, <span class="number">0</span>, OPT_DP_DESC&#125;,</span><br><span class="line">        &#123;<span class="string">"serial_num"</span>,  required_argument, <span class="number">0</span>, OPT_SERIAL_NUM&#125;,</span><br><span class="line">        DAEMON_LONG_OPTIONS,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> indexptr;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">        c = getopt_long(argc, argv, short_options, long_options, &amp;indexptr);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(optarg) != <span class="number">12</span></span><br><span class="line">                || <span class="built_in">strspn</span>(optarg, <span class="string">"0123456789abcdefABCDEF"</span>) != <span class="number">12</span>) &#123;</span><br><span class="line">                ofp_fatal(<span class="number">0</span>, <span class="string">"argument to -d or --datapath-id must be "</span></span><br><span class="line">                          <span class="string">"exactly 12 hex digits"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dpid = strtoll(optarg, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (!dpid) &#123;</span><br><span class="line">                ofp_fatal(<span class="number">0</span>, <span class="string">"argument to -d or --datapath-id must "</span></span><br><span class="line">                          <span class="string">"be nonzero"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            usage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s compiled "</span>__DATE__<span class="string">" "</span>__TIME__<span class="string">"\n"</span>,</span><br><span class="line">                   program_name, VERSION BUILDNR);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">            vlog_set_verbosity(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">            <span class="keyword">if</span> (!port_list) &#123;</span><br><span class="line">                port_list = optarg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                port_list = xasprintf(<span class="string">"%s,%s"</span>, port_list, optarg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            local_port = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_NO_LOCAL_PORT:</span><br><span class="line">            local_port = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_MFR_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(mfr_desc, optarg, <span class="keyword">sizeof</span> mfr_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_HW_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(hw_desc, optarg, <span class="keyword">sizeof</span> hw_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_SW_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(sw_desc, optarg, <span class="keyword">sizeof</span> sw_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_DP_DESC:</span><br><span class="line">            <span class="built_in">strncpy</span>(dp_desc, optarg, <span class="keyword">sizeof</span> dp_desc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_SERIAL_NUM:</span><br><span class="line">            <span class="built_in">strncpy</span>(serial_num, optarg, <span class="keyword">sizeof</span> serial_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OPT_NO_SLICING:</span><br><span class="line">            num_queues = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        DAEMON_OPTION_HANDLERS</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(short_options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主函数</strong>对程序输入参数进行排错判断</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc - optind &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    ofp_fatal(<span class="number">0</span>, <span class="string">"at least one listener argument is required; "</span></span><br><span class="line">      <span class="string">"use --help for usage"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立新的datapath</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error = dp_new(&amp;dp, dpid);</span><br></pre></td></tr></table></figure>
<p>查看 dp_new 函数</p>
<h3 id="dp-new"><a href="#dp-new" class="headerlink" title="dp_new"></a>dp_new</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">dp_new(struct datapath **dp_, <span class="keyword">uint64_t</span> dpid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">datapath</span> *<span class="title">dp</span>;</span></span><br><span class="line"></span><br><span class="line">    dp = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span> *dp);</span><br><span class="line">    <span class="keyword">if</span> (!dp) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp-&gt;last_timeout = time_now();</span><br><span class="line">    list_init(&amp;dp-&gt;remotes);</span><br><span class="line">    dp-&gt;listeners = <span class="literal">NULL</span>;</span><br><span class="line">    dp-&gt;n_listeners = <span class="number">0</span>;</span><br><span class="line">    dp-&gt;id = dpid &lt;= UINT64_C(<span class="number">0xffffffffffff</span>) ? dpid : gen_datapath_id();</span><br><span class="line">    dp-&gt;chain = chain_create(dp);  <span class="comment">//Creates and returns a new chain.</span></span><br><span class="line">    <span class="keyword">if</span> (!dp-&gt;chain) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"could not create chain"</span>);</span><br><span class="line">        <span class="built_in">free</span>(dp);</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;dp-&gt;port_list);</span><br><span class="line">    dp-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    dp-&gt;miss_send_len = OFP_DEFAULT_MISS_SEND_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(&amp;dp_desc) &gt; <span class="number">0</span>)	<span class="comment">/* use the comment, if specified */</span></span><br><span class="line">	    <span class="built_in">strncpy</span>(dp-&gt;dp_desc, &amp;dp_desc, <span class="keyword">sizeof</span> dp-&gt;dp_desc);</span><br><span class="line">    <span class="keyword">else</span>			            <span class="comment">/* else, just use "$HOSTNAME pid=$$" */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> hostnametmp[DESC_STR_LEN];</span><br><span class="line">	    gethostname(hostnametmp,<span class="keyword">sizeof</span> hostnametmp);</span><br><span class="line">        <span class="built_in">snprintf</span>(dp-&gt;dp_desc, <span class="keyword">sizeof</span> dp-&gt;dp_desc,<span class="string">"%s pid=%u"</span>,hostnametmp, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dp_ = dp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数对 datapath 结构体的各成员做出初始化定义，其中比较重要的是 chain ，一起来看一下 <strong>chain_create</strong> 结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Creates and returns a new chain.  Returns NULL if the chain cannot be</span></span><br><span class="line"><span class="comment"> * created. */</span></span><br><span class="line"><span class="function">struct sw_chain *<span class="title">chain_create</span><span class="params">(struct datapath *dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_chain</span> *<span class="title">chain</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span> *<span class="title">chain</span>);</span> <span class="comment">//分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    chain-&gt;dp = dp;</span><br><span class="line">    <span class="keyword">if</span> (add_table(chain, table_hash2_create(<span class="number">0x1EDC6F41</span>, TABLE_HASH_MAX_FLOWS,</span><br><span class="line">                                            <span class="number">0x741B8CD7</span>, TABLE_HASH_MAX_FLOWS),</span><br><span class="line">                                            <span class="number">0</span>)</span><br><span class="line">        || add_table(chain, table_linear_create(TABLE_LINEAR_MAX_FLOWS), <span class="number">0</span>)</span><br><span class="line">        || add_table(chain, table_linear_create(TABLE_LINEAR_MAX_FLOWS), <span class="number">1</span>)) &#123;</span><br><span class="line">        chain_destroy(chain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Attempts to append 'table' to the set of tables in 'chain'.  Returns 0 or</span></span><br><span class="line"><span class="comment"> * negative error.  If 'table' is null it is assumed that table creation failed</span></span><br><span class="line"><span class="comment"> * due to out-of-memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_table</span><span class="params">(struct sw_chain *chain, struct sw_table *table, <span class="keyword">int</span> emerg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (chain-&gt;n_tables &gt;= CHAIN_MAX_TABLES) &#123;</span><br><span class="line">        VLOG_ERR(<span class="string">"too many tables in chain\n"</span>);</span><br><span class="line">        table-&gt;destroy(table);</span><br><span class="line">        <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (emerg)</span><br><span class="line">        chain-&gt;emerg_table = table;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        chain-&gt;tables[chain-&gt;n_tables++] = table;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 main 函数，这一段代码主要实现虚拟通道的建立和连接，不做详解。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">n_listeners = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = optind; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pvconn_name = argv[i];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pvconn</span> *<span class="title">pvconn</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = pvconn_open(pvconn_name, &amp;pvconn);</span><br><span class="line">    <span class="keyword">if</span> (!retval || retval == EAGAIN) &#123;</span><br><span class="line">        dp_add_pvconn(dp, pvconn);</span><br><span class="line">        n_listeners++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ofp_error(retval, <span class="string">"opening %s"</span>, pvconn_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!n_listeners) &#123;</span><br><span class="line">    ofp_fatal(<span class="number">0</span>, <span class="string">"could not listen for any connections"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (port_list) &#123;</span><br><span class="line">    add_ports(dp, port_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (local_port) &#123;</span><br><span class="line">    error = dp_add_local_port(dp, local_port, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        ofp_fatal(error, <span class="string">"failed to add local port %s"</span>, local_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = vlog_server_listen(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    ofp_fatal(error, <span class="string">"could not listen for vlog connections"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果相同程序以存在则停止此程序，运行守护进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">die_if_already_running();</span><br><span class="line">daemonize();</span><br></pre></td></tr></table></figure>
<h3 id="daemonize-void"><a href="#daemonize-void" class="headerlink" title="daemonize(void)"></a>daemonize(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">daemonize(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (detach) &#123;  <span class="comment">//detach是一个bool值，判断是否作为后台程序运行</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (pipe(fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ofp_fatal(errno, <span class="string">"pipe failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* Parent process: wait for child to create pidfile, then exit. */</span></span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            fatal_signal_fork();</span><br><span class="line">            <span class="keyword">if</span> (read(fds[<span class="number">0</span>], &amp;c, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">                ofp_fatal(errno, <span class="string">"daemon child failed to signal startup"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">/* Child process. */</span></span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            make_pidfile();  <span class="comment">//进程文件</span></span><br><span class="line">            write(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>);  <span class="comment">//读写操作</span></span><br><span class="line">            close(fds[<span class="number">1</span>]);</span><br><span class="line">            setsid();</span><br><span class="line">            chdir(<span class="string">"/"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="comment">/* Error. */</span></span><br><span class="line">            ofp_fatal(errno, <span class="string">"could not fork"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        make_pidfile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，主函数建立socket通道。前面提到该AP由<strong>click</strong>模式实现与控制器或上层 openflow 交换机的交互，click相当于一个交换数据的交换机，用不同端口将数据交换隔离开。openflow1.0.0 程序建立 socket 通道，将数据包以 udp 协议传输到click模块中。通道由 make_socket 函数建立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*add the monitor function*/</span></span><br><span class="line">tp = <span class="built_in">realloc</span>(tp, <span class="keyword">sizeof</span>(struct thread_para));</span><br><span class="line">tp-&gt;dp = dp;</span><br><span class="line">make_socket(tp);</span><br></pre></td></tr></table></figure>
<h3 id="make-socket"><a href="#make-socket" class="headerlink" title="make_socket"></a>make_socket</h3><p>thread_para 是一个包含端口port和datapath的结构体，具体定义为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_para</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">border_port</span> *<span class="title">bp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">datapath</span> *<span class="title">dp</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server socket using UDP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_socket</span><span class="params">(struct thread_para *tp)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter make socket function\n"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SERV_PORT = <span class="number">5555</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr , <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET , SOCK_DGRAM , <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_fd = sockfd;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">border_port</span>* <span class="title">bp</span>;</span></span><br><span class="line">    bp = <span class="built_in">realloc</span>(bp, <span class="keyword">sizeof</span>(struct border_port));</span><br><span class="line">    tp-&gt;bp = bp;</span><br><span class="line">    tp-&gt;bp-&gt;fd = sockfd; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd , (struct sockaddr *)&amp;servaddr , <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create server socket\n"</span>);</span><br><span class="line">    <span class="comment">//create thread to send and receive message from click module</span></span><br><span class="line">    <span class="keyword">if</span>( pthread_create(&amp;tid, <span class="literal">NULL</span>, socket_handler, tp) != <span class="number">0</span> )</span><br><span class="line">        pdie(<span class="string">"pthread_create"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台进程建立成功后，主函数中设计了一个死循环，运行 <strong>dp_run, dp_wait, poll_back</strong> 三个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    dp_run(dp);</span><br><span class="line">    dp_wait(dp);</span><br><span class="line">    poll_block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要来看一下 dp_run 函数，其余的 dp_wait 和 poll_block 函数不做详解。</p>
<h3 id="dp-run"><a href="#dp-run" class="headerlink" title="dp_run"></a>dp_run</h3><p>此函数顾名思义就是运行一个datapath，其中主要重要的函数包括 <strong>netdev_recv</strong> 、<strong>fwd_port_input</strong> 和 <strong>remote_run</strong> ，将会在后面具体分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dp_run(struct datapath *dp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now = time_now();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_port</span> *<span class="title">p</span>, *<span class="title">pn</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remote</span> *<span class="title">r</span>, *<span class="title">rn</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *<span class="title">buffer</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now != dp-&gt;last_timeout) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">deleted</span> = <span class="title">LIST_INITIALIZER</span>(&amp;<span class="title">deleted</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">f</span>, *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">        chain_timeout(dp-&gt;chain, &amp;deleted);</span><br><span class="line">        LIST_FOR_EACH_SAFE (f, n, struct sw_flow, node, &amp;deleted) &#123;</span><br><span class="line">            dp_send_flow_end(dp, f, f-&gt;reason);</span><br><span class="line">            list_remove(&amp;f-&gt;node);</span><br><span class="line">            flow_free(f);</span><br><span class="line">        &#125;</span><br><span class="line">        dp-&gt;last_timeout = now;</span><br><span class="line">    &#125;</span><br><span class="line">    poll_timer_wait(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以上对超时做了排错处理</span></span><br><span class="line"><span class="comment"> * dp_send_flow_end 将错误代码发送到控制器，具体分析见下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    LIST_FOR_EACH_SAFE (p, pn, struct sw_port, node, &amp;dp-&gt;port_list) &#123;</span><br><span class="line">        <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">            <span class="comment">/* Allocate buffer with some headroom to add headers in forwarding</span></span><br><span class="line"><span class="comment">             * to the controller or adding a vlan tag, plus an extra 2 bytes to</span></span><br><span class="line"><span class="comment">             * allow IP headers to be aligned on a 4-byte boundary.  */</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> headroom = <span class="number">128</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> hard_header = VLAN_ETH_HEADER_LEN;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> mtu = netdev_get_mtu(p-&gt;netdev);</span><br><span class="line">            buffer = ofpbuf_new(headroom + hard_header + mtu);</span><br><span class="line">            buffer-&gt;data = (<span class="keyword">char</span>*)buffer-&gt;data + headroom;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * buffer用来暂时存储netdevice的数据包</span></span><br><span class="line"><span class="comment">  * ofbuf_new 定义了一个空的buffer空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        error = netdev_recv(p-&gt;netdev, buffer);</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            p-&gt;rx_packets++;</span><br><span class="line">            p-&gt;rx_bytes += buffer-&gt;size;</span><br><span class="line">            fwd_port_input(dp, buffer, p);</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != EAGAIN) &#123;</span><br><span class="line">            VLOG_ERR_RL(&amp;rl, <span class="string">"error receiving data from %s: %s"</span>,</span><br><span class="line">                        netdev_get_name(p-&gt;netdev), strerror(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ofpbuf_delete(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 建立与Controller之间的安全信道</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Talk to remotes. */</span></span><br><span class="line">    LIST_FOR_EACH_SAFE (r, rn, struct remote, node, &amp;dp-&gt;remotes) &#123;</span><br><span class="line">        remote_run(dp, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dp-&gt;n_listeners; ) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pvconn</span> *<span class="title">pvconn</span> = <span class="title">dp</span>-&gt;<span class="title">listeners</span>[<span class="title">i</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> *<span class="title">new_vconn</span>;</span></span><br><span class="line">        <span class="keyword">int</span> retval = pvconn_accept(pvconn, OFP_VERSION, &amp;new_vconn);</span><br><span class="line">        <span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">            remote_create(dp, rconn_new_from_vconn(<span class="string">"passive"</span>, new_vconn));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval != EAGAIN) &#123;</span><br><span class="line">            VLOG_WARN_RL(&amp;rl, <span class="string">"accept failed (%s)"</span>, strerror(retval));</span><br><span class="line">            dp-&gt;listeners[i] = dp-&gt;listeners[--dp-&gt;n_listeners];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ofpbuf_new</strong> 提供一个空的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *</span></span><br><span class="line"><span class="class"><span class="title">ofpbuf_new</span>(<span class="title">size_t</span> <span class="title">size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *<span class="title">b</span> = <span class="title">xmalloc</span>(<span class="title">sizeof</span> *<span class="title">b</span>);</span></span><br><span class="line">    ofpbuf_init(b, size);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="netdev-recv"><a href="#netdev-recv" class="headerlink" title="netdev_recv"></a>netdev_recv</h4><p><strong>netdev_recv</strong> 将网络设备接受到的数据包存进缓存空间。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">netdev_recv(struct netdev *netdev, struct ofpbuf *buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n_bytes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sll</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> sll_len;</span><br><span class="line"></span><br><span class="line">    assert(buffer-&gt;size == <span class="number">0</span>);</span><br><span class="line">    assert(ofpbuf_tailroom(buffer) &gt;= ETH_TOTAL_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* prepare to call recvfrom */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sll,<span class="number">0</span>,<span class="keyword">sizeof</span> sll);</span><br><span class="line">    sll_len = <span class="keyword">sizeof</span> sll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cannot execute recvfrom over a tap device */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(netdev-&gt;name, <span class="string">"tap"</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            n_bytes = read(netdev-&gt;tap_fd, ofpbuf_tail(buffer),</span><br><span class="line">                           (<span class="keyword">ssize_t</span>)ofpbuf_tailroom(buffer));</span><br><span class="line">        &#125; <span class="keyword">while</span> (n_bytes &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            n_bytes = recvfrom(netdev-&gt;tap_fd, ofpbuf_tail(buffer),</span><br><span class="line">                               (<span class="keyword">ssize_t</span>)ofpbuf_tailroom(buffer), <span class="number">0</span>,</span><br><span class="line">                               (struct sockaddr *)&amp;sll, &amp;sll_len);</span><br><span class="line">        &#125; <span class="keyword">while</span> (n_bytes &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n_bytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            VLOG_WARN_RL(&amp;rl, <span class="string">"error receiving Ethernet packet on %s: %s"</span>,</span><br><span class="line">                         strerror(errno), netdev-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* we have multiple raw sockets at the same interface, so we also</span></span><br><span class="line"><span class="comment">         * receive what others send, and need to filter them out.</span></span><br><span class="line"><span class="comment">         * TODO(yiannisy): can we install this as a BPF at kernel? */</span></span><br><span class="line">        <span class="keyword">if</span> (sll.sll_pkttype == PACKET_OUTGOING) &#123;</span><br><span class="line">            <span class="keyword">return</span> EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        buffer-&gt;size += n_bytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the kernel internally sends out an Ethernet frame on an</span></span><br><span class="line"><span class="comment">         * interface, it gives us a copy *before* padding the frame to the</span></span><br><span class="line"><span class="comment">         * minimum length.  Thus, when it sends out something like an ARP</span></span><br><span class="line"><span class="comment">         * request, we see a too-short frame.  So pad it out to the minimum</span></span><br><span class="line"><span class="comment">         * length. */</span></span><br><span class="line">        pad_to_minimum_length(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数利用 <a href="https://blog.csdn.net/liangkaiyang/article/details/5931901" target="_blank" rel="noopener"><strong>recvfrom</strong></a> 函数将网络设备收到的数据存储在 buffer 的 ofpbuf_tail 中。接受到数据包之后， <strong>fwd_port_input</strong> 函数首先对其处理。</p>
<h4 id="fwd-port-input"><a href="#fwd-port-input" class="headerlink" title="fwd_port_input"></a>fwd_port_input</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 'buffer' was received on 'p', which may be a a physical switch port or a</span></span><br><span class="line"><span class="comment"> * null pointer.  Process it according to 'dp''s flow table, sending it up to</span></span><br><span class="line"><span class="comment"> * the controller if no flow matches.  Takes ownership of 'buffer'. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwd_port_input</span><span class="params">(struct datapath *dp, struct ofpbuf *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct sw_port *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (run_flow_through_tables(dp, buffer, p)) &#123;</span><br><span class="line">        dp_output_control(dp, buffer, p-&gt;port_no,</span><br><span class="line">                          dp-&gt;miss_send_len, OFPR_NO_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据包首先由 <strong>run_flow_through_tables</strong> 判断是否需要输出至控制器，再由 <strong>dp_output_control</strong> 函数操作。</p>
<h4 id="run-flow-through-tables"><a href="#run-flow-through-tables" class="headerlink" title="run_flow_through_tables"></a>run_flow_through_tables</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 'buffer' was received on 'p', which may be a a physical switch port or a</span></span><br><span class="line"><span class="comment"> * null pointer.  Process it according to 'dp''s flow table.  Returns 0 if</span></span><br><span class="line"><span class="comment"> * successful, in which case 'buffer' is destroyed, or -ESRCH if there is no</span></span><br><span class="line"><span class="comment"> * matching flow, in which case 'buffer' still belongs to the caller. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_flow_through_tables</span><span class="params">(struct datapath *dp, struct ofpbuf *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct sw_port *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_key</span> <span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span>;</span></span><br><span class="line"></span><br><span class="line">    key.wildcards = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (flow_extract(buffer, p ? p-&gt;port_no : OFPP_NONE, &amp;key.flow)</span><br><span class="line">        &amp;&amp; (dp-&gt;flags &amp; OFPC_FRAG_MASK) == OFPC_FRAG_DROP) &#123;</span><br><span class="line">        <span class="comment">/* Drop fragment. */</span></span><br><span class="line">        ofpbuf_delete(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;config &amp; (OFPPC_NO_RECV | OFPPC_NO_RECV_STP)</span><br><span class="line">        &amp;&amp; p-&gt;config &amp; (!eth_addr_equals(key.flow.dl_dst, stp_eth_addr)</span><br><span class="line">                       ? OFPPC_NO_RECV : OFPPC_NO_RECV_STP)) &#123;</span><br><span class="line">        ofpbuf_delete(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flow = chain_lookup(dp-&gt;chain, &amp;key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        flow_used(flow, buffer);</span><br><span class="line">        execute_actions(dp, buffer, &amp;key, flow-&gt;sf_acts-&gt;actions,</span><br><span class="line">                        flow-&gt;sf_acts-&gt;actions_len, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -ESRCH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<strong>flow_extract</strong> 解析数据包，该函数主要判断数据包是否为IP数据包，是则返回1；否则返回0。如果是IP数据包，程序将删除这一缓存，不进行下一步处理。同时，函数将数据包中的各信息位信息存储到结构体 <strong>flow</strong> 中。flow 由 sw_flow 定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_key</span> <span class="title">key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> cookie;            <span class="comment">/* Opaque controller-issued identifier. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> priority;          <span class="comment">/* Only used on entries with wildcards. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> idle_timeout;      <span class="comment">/* Idle time before discarding (seconds). */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hard_timeout;      <span class="comment">/* Hard expiration time (seconds) */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> used;              <span class="comment">/* Last used time. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> created;           <span class="comment">/* When the flow was created. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> packet_count;      <span class="comment">/* Number of packets seen. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> byte_count;        <span class="comment">/* Number of bytes seen. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reason;             <span class="comment">/* Reason flow removed (one of OFPRR_*). */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> send_flow_rem;      <span class="comment">/* Send a flow removed to the controller */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> emerg_flow;         <span class="comment">/* Emergency flow indicator */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sf_acts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Private to table implementations. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">iter_node</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> serial;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数据流解析函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns 1 if 'packet' is an IP fragment, 0 otherwise. */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">flow_extract(struct ofpbuf *packet, <span class="keyword">uint16_t</span> in_port, struct flow *flow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> <span class="title">b</span> = *<span class="title">packet</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eth_header</span> *<span class="title">eth</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(flow, <span class="number">0</span>, <span class="keyword">sizeof</span> *flow);</span><br><span class="line">    flow-&gt;dl_vlan = htons(OFP_VLAN_NONE);</span><br><span class="line">    flow-&gt;in_port = htons(in_port);</span><br><span class="line"></span><br><span class="line">    packet-&gt;l2 = b.data;</span><br><span class="line">    packet-&gt;l3 = <span class="literal">NULL</span>;</span><br><span class="line">    packet-&gt;l4 = <span class="literal">NULL</span>;</span><br><span class="line">    packet-&gt;l7 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    eth = pull_eth(&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (eth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ntohs(eth-&gt;eth_type) &gt;= OFP_DL_TYPE_ETH2_CUTOFF) &#123;</span><br><span class="line">            <span class="comment">/* This is an Ethernet II frame */</span></span><br><span class="line">            flow-&gt;dl_type = eth-&gt;eth_type;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* This is an 802.2 frame */</span></span><br><span class="line">            struct llc_header *llc = ofpbuf_at(&amp;b, <span class="number">0</span>, <span class="keyword">sizeof</span> *llc);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">snap_header</span> *<span class="title">snap</span> = <span class="title">ofpbuf_at</span>(&amp;<span class="title">b</span>, <span class="title">sizeof</span> *<span class="title">llc</span>,</span></span><br><span class="line"><span class="class">                                                 <span class="title">sizeof</span> *<span class="title">snap</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (llc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (snap</span><br><span class="line">                &amp;&amp; llc-&gt;llc_dsap == LLC_DSAP_SNAP</span><br><span class="line">                &amp;&amp; llc-&gt;llc_ssap == LLC_SSAP_SNAP</span><br><span class="line">                &amp;&amp; llc-&gt;llc_cntl == LLC_CNTL_SNAP</span><br><span class="line">                &amp;&amp; !<span class="built_in">memcmp</span>(snap-&gt;snap_org, SNAP_ORG_ETHERNET,</span><br><span class="line">                           <span class="keyword">sizeof</span> snap-&gt;snap_org)) &#123;</span><br><span class="line">                flow-&gt;dl_type = snap-&gt;snap_type;</span><br><span class="line">                ofpbuf_pull(&amp;b, LLC_SNAP_HEADER_LEN);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flow-&gt;dl_type = htons(OFP_DL_TYPE_NOT_ETH_TYPE);</span><br><span class="line">                ofpbuf_pull(&amp;b, <span class="keyword">sizeof</span>(struct llc_header));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check for a VLAN tag */</span></span><br><span class="line">        <span class="keyword">if</span> (flow-&gt;dl_type == htons(ETH_TYPE_VLAN)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vlan_header</span> *<span class="title">vh</span> = <span class="title">pull_vlan</span>(&amp;<span class="title">b</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (vh) &#123;</span><br><span class="line">                flow-&gt;dl_type = vh-&gt;vlan_next_type;</span><br><span class="line">                flow-&gt;dl_vlan = vh-&gt;vlan_tci &amp; htons(VLAN_VID_MASK);</span><br><span class="line">                flow-&gt;dl_vlan_pcp = (<span class="keyword">uint8_t</span>)((ntohs(vh-&gt;vlan_tci) &gt;&gt; VLAN_PCP_SHIFT)</span><br><span class="line">                                               &amp; VLAN_PCP_BITMASK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(flow-&gt;dl_src, eth-&gt;eth_src, ETH_ADDR_LEN);</span><br><span class="line">        <span class="built_in">memcpy</span>(flow-&gt;dl_dst, eth-&gt;eth_dst, ETH_ADDR_LEN);</span><br><span class="line"></span><br><span class="line">        packet-&gt;l3 = b.data;</span><br><span class="line">        <span class="keyword">if</span> (flow-&gt;dl_type == htons(ETH_TYPE_IP)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_header</span> *<span class="title">nh</span> = <span class="title">pull_ip</span>(&amp;<span class="title">b</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (nh) &#123;</span><br><span class="line">                flow-&gt;nw_tos = nh-&gt;ip_tos &amp; <span class="number">0xfc</span>;</span><br><span class="line">                flow-&gt;nw_proto = nh-&gt;ip_proto;</span><br><span class="line">                flow-&gt;nw_src = nh-&gt;ip_src;</span><br><span class="line">                flow-&gt;nw_dst = nh-&gt;ip_dst;</span><br><span class="line">                packet-&gt;l4 = b.data;</span><br><span class="line">                <span class="keyword">if</span> (!IP_IS_FRAGMENT(nh-&gt;ip_frag_off)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (flow-&gt;nw_proto == IP_TYPE_TCP) &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span> *<span class="title">tcp</span> = <span class="title">pull_tcp</span>(&amp;<span class="title">b</span>);</span></span><br><span class="line">                        <span class="keyword">if</span> (tcp) &#123;</span><br><span class="line">                            flow-&gt;tp_src = tcp-&gt;tcp_src;</span><br><span class="line">                            flow-&gt;tp_dst = tcp-&gt;tcp_dst;</span><br><span class="line">                            packet-&gt;l7 = b.data;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Avoid tricking other code into thinking that</span></span><br><span class="line"><span class="comment">                             * this packet has an L4 header. */</span></span><br><span class="line">                            flow-&gt;nw_proto = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow-&gt;nw_proto == IP_TYPE_UDP) &#123;</span><br><span class="line">                        <span class="keyword">const</span> struct udp_header *udp = pull_udp(&amp;b);</span><br><span class="line">                        <span class="keyword">if</span> (udp) &#123;</span><br><span class="line">                            flow-&gt;tp_src = udp-&gt;udp_src;</span><br><span class="line">                            flow-&gt;tp_dst = udp-&gt;udp_dst;</span><br><span class="line">                            packet-&gt;l7 = b.data;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Avoid tricking other code into thinking that</span></span><br><span class="line"><span class="comment">                             * this packet has an L4 header. */</span></span><br><span class="line">                            flow-&gt;nw_proto = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow-&gt;nw_proto == IP_TYPE_ICMP) &#123;</span><br><span class="line">                        <span class="keyword">const</span> struct icmp_header *icmp = pull_icmp(&amp;b);</span><br><span class="line">                        <span class="keyword">if</span> (icmp) &#123;</span><br><span class="line">                            flow-&gt;icmp_type = htons(icmp-&gt;icmp_type);</span><br><span class="line">                            flow-&gt;icmp_code = htons(icmp-&gt;icmp_code);</span><br><span class="line">                            packet-&gt;l7 = b.data;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Avoid tricking other code into thinking that</span></span><br><span class="line"><span class="comment">                             * this packet has an L4 header. */</span></span><br><span class="line">                            flow-&gt;nw_proto = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    retval = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flow-&gt;dl_type == htons(ETH_TYPE_ARP)) &#123;</span><br><span class="line">            <span class="keyword">const</span> struct arp_eth_header *arp = pull_arp(&amp;b);</span><br><span class="line">            <span class="keyword">if</span> (arp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arp-&gt;ar_pro == htons(ARP_PRO_IP) &amp;&amp; arp-&gt;ar_pln == IP_ADDR_LEN) &#123;</span><br><span class="line">                    flow-&gt;nw_src = arp-&gt;ar_spa;</span><br><span class="line">                    flow-&gt;nw_dst = arp-&gt;ar_tpa;</span><br><span class="line">                &#125;</span><br><span class="line">                flow-&gt;nw_proto = ntohs(arp-&gt;ar_op) &amp;&amp; <span class="number">0xff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是一个IP数据，数据包的信息现已存储在结构体 <strong>flow</strong> 中。</p>
<p>接着，通过 <strong>chain_lookup</strong> 函数为此数据包匹配对应的 <strong>key</strong> 并存入 <strong>flow</strong> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Searches 'chain' for a flow matching 'key', which must not have any wildcard</span></span><br><span class="line"><span class="comment"> * fields.  Returns the flow if successful, otherwise a null pointer. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *</span></span><br><span class="line"><span class="class"><span class="title">chain_lookup</span>(<span class="title">struct</span> <span class="title">sw_chain</span> *<span class="title">chain</span>, <span class="title">const</span> <span class="title">struct</span> <span class="title">sw_flow_key</span> *<span class="title">key</span>, <span class="title">int</span> <span class="title">emerg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    assert(!key-&gt;wildcards);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (emerg) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_table</span> *<span class="title">t</span> = <span class="title">chain</span>-&gt;<span class="title">emerg_table</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span> = <span class="title">t</span>-&gt;<span class="title">lookup</span>(<span class="title">t</span>, <span class="title">key</span>);</span></span><br><span class="line">        t-&gt;n_lookup++;</span><br><span class="line">        <span class="keyword">if</span> (flow) &#123;</span><br><span class="line">            t-&gt;n_matched++;</span><br><span class="line">            <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chain-&gt;n_tables; i++) &#123;</span><br><span class="line">            struct sw_table *t = chain-&gt;tables[i];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span> = <span class="title">t</span>-&gt;<span class="title">lookup</span>(<span class="title">t</span>, <span class="title">key</span>);</span></span><br><span class="line">            t-&gt;n_lookup++;</span><br><span class="line">            <span class="keyword">if</span> (flow) &#123;</span><br><span class="line">                t-&gt;n_matched++;</span><br><span class="line">                <span class="keyword">return</span> flow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后， <strong>execute_actions</strong> 函数执行该flow的 <strong>action</strong> 。</p>
<h4 id="execute-actions"><a href="#execute-actions" class="headerlink" title="execute_actions"></a>execute_actions</h4><p>此函数需要的参数包括 datapath，buffer，key，acitons，actions_len。</p>
<p>由函数的调用可以看到，actions 和 actions_len 存储在flow的 <strong>sw_flow_actions</strong> 结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute a list of actions against 'buffer'. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_actions</span><span class="params">(struct datapath *dp, struct ofpbuf *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">             struct sw_flow_key *key,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct ofp_action_header *actions, <span class="keyword">size_t</span> actions_len,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> ignore_no_fwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Every output action needs a separate clone of 'buffer', but the common</span></span><br><span class="line"><span class="comment">     * case is just a single output action, so that doing a clone and then</span></span><br><span class="line"><span class="comment">     * freeing the original buffer is wasteful.  So the following code is</span></span><br><span class="line"><span class="comment">     * slightly obscure just to avoid that. */</span></span><br><span class="line">    <span class="keyword">int</span> prev_port;</span><br><span class="line">    <span class="keyword">uint32_t</span> prev_queue;</span><br><span class="line">    <span class="keyword">size_t</span> max_len = UINT16_MAX;</span><br><span class="line">    <span class="keyword">uint16_t</span> in_port = ntohs(key-&gt;flow.in_port);</span><br><span class="line">    <span class="keyword">uint8_t</span> *p = (<span class="keyword">uint8_t</span> *)actions;</span><br><span class="line"></span><br><span class="line">    prev_port = <span class="number">-1</span>;</span><br><span class="line">    prev_queue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The action list was already validated, so we can be a bit looser</span></span><br><span class="line"><span class="comment">     * in our sanity-checking. */</span></span><br><span class="line">    <span class="keyword">while</span> (actions_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ofp_action_header</span> *<span class="title">ah</span> = (<span class="title">struct</span> <span class="title">ofp_action_header</span> *)<span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> len = htons(ah-&gt;len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev_port != <span class="number">-1</span>) &#123;</span><br><span class="line">            do_output(dp, ofpbuf_clone(buffer), in_port, max_len,</span><br><span class="line">                      prev_port, prev_queue, ignore_no_fwd);</span><br><span class="line">            prev_port = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ah-&gt;type == htons(OFPAT_OUTPUT)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ofp_action_output</span> *<span class="title">oa</span> = (<span class="title">struct</span> <span class="title">ofp_action_output</span> *)<span class="title">p</span>;</span></span><br><span class="line">            prev_port = ntohs(oa-&gt;port);</span><br><span class="line">            prev_queue = <span class="number">0</span>; <span class="comment">/* using the default best-effort queue */</span></span><br><span class="line">            max_len = ntohs(oa-&gt;max_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ah-&gt;type == htons(OFPAT_ENQUEUE)) &#123;</span><br><span class="line">            struct ofp_action_enqueue *ea = (struct ofp_action_enqueue *)p;</span><br><span class="line">            prev_port = ntohs(ea-&gt;port);</span><br><span class="line">            prev_queue = ntohl(ea-&gt;queue_id);</span><br><span class="line">            max_len = <span class="number">0</span>; <span class="comment">/* we will not send to the controller anyways - useless */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">uint16_t</span> type = ntohs(ah-&gt;type);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type &lt; ARRAY_SIZE(of_actions)) &#123;</span><br><span class="line">                execute_ofpat(buffer, key, ah, type);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == OFPAT_VENDOR) &#123;</span><br><span class="line">                execute_vendor(buffer, key, ah);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p += len;</span><br><span class="line">        actions_len -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev_port != <span class="number">-1</span>) &#123;</span><br><span class="line">        do_output(dp, buffer, in_port, max_len, prev_port, prev_queue, ignore_no_fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ofpbuf_delete(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数确定转发前后的端口，对 OpenFlow 协议的 build-in action 和 vendor aciton 分别执行 <strong>execute_ofpact</strong> 和 <strong>execute_vendor</strong> ，其他 actions 统一由 <strong>do_output</strong> 执行。</p>
<h4 id="do-output"><a href="#do-output" class="headerlink" title="do_output"></a>do_output</h4><p>函数首先根据输出端口判断该数据包是转发给控制器的还是由端口输出的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_output(struct datapath *dp, struct ofpbuf *buffer, <span class="keyword">int</span> in_port,</span><br><span class="line">          <span class="keyword">size_t</span> max_len, <span class="keyword">int</span> out_port, <span class="keyword">uint32_t</span> queue_id,</span><br><span class="line">          <span class="keyword">bool</span> ignore_no_fwd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (out_port != OFPP_CONTROLLER) &#123;</span><br><span class="line">        dp_output_port(dp, buffer, in_port, out_port, queue_id, ignore_no_fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp_output_control(dp, buffer, in_port, max_len, OFPR_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="do-output-port"><a href="#do-output-port" class="headerlink" title="do_output_port"></a>do_output_port</h5><p>根据不同的 out_port 对数据包进行处理，涉及的处理函数有 <strong>output_packet</strong> ，<strong>output_all</strong> 和 <strong>dp_output_control</strong> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Takes ownership of 'buffer' and transmits it to 'out_port' on 'dp'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dp_output_port(struct datapath *dp, struct ofpbuf *buffer,</span><br><span class="line">               <span class="keyword">int</span> in_port, <span class="keyword">int</span> out_port, <span class="keyword">uint32_t</span> queue_id,</span><br><span class="line">               <span class="keyword">bool</span> ignore_no_fwd UNUSED)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    assert(buffer);</span><br><span class="line">    <span class="keyword">switch</span> (out_port) &#123;</span><br><span class="line">    <span class="keyword">case</span> OFPP_IN_PORT:</span><br><span class="line">        output_packet(dp, buffer, in_port, queue_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_TABLE: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sw_port</span> *<span class="title">p</span> = <span class="title">dp_lookup_port</span>(<span class="title">dp</span>, <span class="title">in_port</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (run_flow_through_tables(dp, buffer, p)) &#123;</span><br><span class="line">            ofpbuf_delete(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_FLOOD:</span><br><span class="line">        output_all(dp, buffer, in_port, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_ALL:</span><br><span class="line">        output_all(dp, buffer, in_port, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_CONTROLLER:</span><br><span class="line">        dp_output_control(dp, buffer, in_port, UINT16_MAX, OFPR_ACTION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OFPP_LOCAL:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (in_port == out_port) &#123;</span><br><span class="line">            VLOG_DBG_RL(&amp;rl, <span class="string">"can't directly forward to input port"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output_packet(dp, buffer, out_port, queue_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>output_packet 函数利用 <strong>netdev_send</strong> 函数将数据包由网络设备发出。</li>
<li>output_all 函数将数据包从所有端口发出，在函数内调用 do_output_port ，每次发送后将端口号加1继续发送。</li>
</ul>
<h5 id="do-output-control"><a href="#do-output-control" class="headerlink" title="do_output_control"></a>do_output_control</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Takes ownership of 'buffer' and transmits it to 'dp''s controller.  If the</span></span><br><span class="line"><span class="comment"> * packet can be saved in a buffer, then only the first max_len bytes of</span></span><br><span class="line"><span class="comment"> * 'buffer' are sent; otherwise, all of 'buffer' is sent.  'reason' indicates</span></span><br><span class="line"><span class="comment"> * why 'buffer' is being sent. 'max_len' sets the maximum number of bytes that</span></span><br><span class="line"><span class="comment"> * the caller wants to be sent. */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dp_output_control(struct datapath *dp, struct ofpbuf *buffer, <span class="keyword">int</span> in_port,</span><br><span class="line">                  <span class="keyword">size_t</span> max_len, <span class="keyword">int</span> reason)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofp_packet_in</span> *<span class="title">opi</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> total_len;</span><br><span class="line">    <span class="keyword">uint32_t</span> buffer_id;</span><br><span class="line"></span><br><span class="line">    buffer_id = save_buffer(buffer);</span><br><span class="line">    total_len = buffer-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (buffer_id != UINT32_MAX &amp;&amp; buffer-&gt;size &gt; max_len) &#123;</span><br><span class="line">        buffer-&gt;size = max_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opi = ofpbuf_push_uninit(buffer, offsetof(struct ofp_packet_in, data));</span><br><span class="line">    opi-&gt;header.version = OFP_VERSION;</span><br><span class="line">    opi-&gt;header.type    = OFPT_PACKET_IN;</span><br><span class="line">    opi-&gt;header.length  = htons(buffer-&gt;size);</span><br><span class="line">    opi-&gt;header.xid     = htonl(<span class="number">0</span>);</span><br><span class="line">    opi-&gt;buffer_id      = htonl(buffer_id);</span><br><span class="line">    opi-&gt;total_len      = htons(total_len);</span><br><span class="line">    opi-&gt;in_port        = htons(in_port);</span><br><span class="line">    opi-&gt;reason         = reason;</span><br><span class="line">    opi-&gt;pad            = <span class="number">0</span>;</span><br><span class="line">    send_openflow_buffer(dp, buffer, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数利用 <strong>ofpbuf_push_uninit</strong> 函数重构 buffer 的数据包头部，然后用 <strong>send_openflow_buffer</strong> 函数将 buffer 发出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ofpbuf_push_uninit(struct ofpbuf *b, <span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    ofpbuf_prealloc_headroom(b, size);</span><br><span class="line">    b-&gt;data = (<span class="keyword">char</span>*)b-&gt;data - size;</span><br><span class="line">    b-&gt;size += size;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析 send_openflow_buffer 函数之前，先来看一下之前提到的 <strong>remote_run</strong> 函数。</p>
<h4 id="remote-run"><a href="#remote-run" class="headerlink" title="remote_run"></a>remote_run</h4><p>此函数主要通过构建虚拟连接来建立一个远程进程，我的个人理解是通过这个函数来建立AP与Controller之间的安全信道。</p>
<p>首先，结构体 <strong>remote</strong> 构建了一个安全信道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A connection to a secure channel. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remote</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rconn</span> *<span class="title">rconn</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TXQ_LIMIT 128           <span class="comment">/* Max number of packets to queue for tx. */</span></span></span><br><span class="line">    <span class="keyword">int</span> n_txq;                  <span class="comment">/* Number of packets queued for tx on rconn. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Support for reliable, multi-message replies to requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If an incoming request needs to have a reliable reply that might</span></span><br><span class="line"><span class="comment">     * require multiple messages, it can use remote_start_dump() to set up</span></span><br><span class="line"><span class="comment">     * a callback that will be called as buffer space for replies. */</span></span><br><span class="line">    <span class="keyword">int</span> (*cb_dump)(struct datapath *, <span class="keyword">void</span> *aux);</span><br><span class="line">    <span class="keyword">void</span> (*cb_done)(<span class="keyword">void</span> *aux);</span><br><span class="line">    <span class="keyword">void</span> *cb_aux;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体 <strong>rconn</strong> 被定义为一个连接控制器或交换机的可靠连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A reliable connection to an OpenFlow switch or controller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See the large comment in rconn.h for more information. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rconn</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> state state;</span><br><span class="line">    <span class="keyword">time_t</span> state_entered;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> *<span class="title">vconn</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">bool</span> reliable;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofp_queue</span> <span class="title">txq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> backoff;</span><br><span class="line">    <span class="keyword">int</span> max_backoff;</span><br><span class="line">    <span class="keyword">time_t</span> backoff_deadline;</span><br><span class="line">    <span class="keyword">time_t</span> last_received;</span><br><span class="line">    <span class="keyword">time_t</span> last_connected;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packets_sent;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seqno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In S_ACTIVE and S_IDLE, probably_admitted reports whether we believe</span></span><br><span class="line"><span class="comment">     * that the peer has made a (positive) admission control decision on our</span></span><br><span class="line"><span class="comment">     * connection.  If we have not yet been (probably) admitted, then the</span></span><br><span class="line"><span class="comment">     * connection does not reset the timer used for deciding whether the switch</span></span><br><span class="line"><span class="comment">     * should go into fail-open mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * last_admitted reports the last time we believe such a positive admission</span></span><br><span class="line"><span class="comment">     * control decision was made. */</span></span><br><span class="line">    <span class="keyword">bool</span> probably_admitted;</span><br><span class="line">    <span class="keyword">time_t</span> last_admitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These values are simply for statistics reporting, not used directly by</span></span><br><span class="line"><span class="comment">     * anything internal to the rconn (or the secchan for that matter). */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packets_received;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n_attempted_connections, n_successful_connections;</span><br><span class="line">    <span class="keyword">time_t</span> creation_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> total_time_connected;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we can't connect to the peer, it could be for any number of reasons.</span></span><br><span class="line"><span class="comment">     * Usually, one would assume it is because the peer is not running or</span></span><br><span class="line"><span class="comment">     * because the network is partitioned.  But it could also be because the</span></span><br><span class="line"><span class="comment">     * network topology has changed, in which case the upper layer will need to</span></span><br><span class="line"><span class="comment">     * reassess it (in particular, obtain a new IP address via DHCP and find</span></span><br><span class="line"><span class="comment">     * the new location of the controller).  We set this flag when we suspect</span></span><br><span class="line"><span class="comment">     * that this could be the case. */</span></span><br><span class="line">    <span class="keyword">bool</span> questionable_connectivity;</span><br><span class="line">    <span class="keyword">time_t</span> last_questioned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Throughout this file, "probe" is shorthand for "inactivity probe".</span></span><br><span class="line"><span class="comment">     * When nothing has been received from the peer for a while, we send out</span></span><br><span class="line"><span class="comment">     * an echo request as an inactivity probe packet.  We should receive back</span></span><br><span class="line"><span class="comment">     * a response. */</span></span><br><span class="line">    <span class="keyword">int</span> probe_interval;         <span class="comment">/* Secs of inactivity before sending probe. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Messages sent or received are copied to the monitor connections. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MONITORS 8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> *<span class="title">monitors</span>[8];</span></span><br><span class="line">    <span class="keyword">size_t</span> n_monitors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protocol statistical informaition. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_rcvd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_sent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> idle_echo_xid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个虚拟的连接，具体连接又由 <strong>vconn-provider</strong> 提供，包括状态、版本、IP以及接收和发送的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Active virtual connection to an OpenFlow device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure should be treated as opaque by vconn implementations. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vconn</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vconn_class</span> *<span class="title">class</span>;</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> min_version;</span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">bool</span> reconnectable;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_rcvd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofpstat</span> <span class="title">ofps_sent</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，总而言之可以把 remote 视为AP的安全信道。</p>
<p>在解析remote_run函数前，还要说明一个结构体：sender。sender由remote结构体和一个id组成，用以表示接收到的 OpenFlow 消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The origin of a received OpenFlow message, to enable sending a reply. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sender</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remote</span> *<span class="title">remote</span>;</span>      <span class="comment">/* The device that sent the message. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> xid;               <span class="comment">/* The OpenFlow transaction ID. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>remote_run</strong> 函数主要职责是保持安全信道运行并捕获由controller发来的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">remote_run(struct datapath *dp, struct remote *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    rconn_run(r-&gt;rconn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do some remote processing, but cap it at a reasonable amount so that</span></span><br><span class="line"><span class="comment">     * other processing doesn't starve. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!r-&gt;cb_dump) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ofpbuf</span> *<span class="title">buffer</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ofp_header</span> *<span class="title">oh</span>;</span></span><br><span class="line"></span><br><span class="line">            buffer = rconn_recv(r-&gt;rconn);</span><br><span class="line">            <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buffer-&gt;size &gt;= <span class="keyword">sizeof</span> *oh) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sender</span> <span class="title">sender</span>;</span></span><br><span class="line"></span><br><span class="line">                oh = (struct ofp_header *)buffer-&gt;data;</span><br><span class="line">                sender.remote = r;</span><br><span class="line">                sender.xid = oh-&gt;xid;</span><br><span class="line">                fwd_control_input(dp, &amp;sender, buffer-&gt;data, buffer-&gt;size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                VLOG_WARN_RL(&amp;rl, <span class="string">"received too-short OpenFlow message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ofpbuf_delete(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;n_txq &lt; TXQ_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">int</span> error = r-&gt;cb_dump(dp, r-&gt;cb_aux);</span><br><span class="line">                <span class="keyword">if</span> (error &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                        VLOG_WARN_RL(&amp;rl, <span class="string">"dump callback error: %s"</span>,</span><br><span class="line">                                     strerror(-error));</span><br><span class="line">                    &#125;</span><br><span class="line">                    r-&gt;cb_done(r-&gt;cb_aux);</span><br><span class="line">                    r-&gt;cb_dump = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rconn_is_alive(r-&gt;rconn)) &#123;</span><br><span class="line">        remote_destroy(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>rconn_run 函数建立连接。</li>
<li>rconn_recv 接受连接中的数据包，并将数据包存储在 buffer 中。</li>
<li><strong>fwd_control_input</strong> 解析接收到的数据包并进行下一步操作。</li>
</ul>
<h4 id="fwd-control-input"><a href="#fwd-control-input" class="headerlink" title="fwd_control_input"></a>fwd<strong>_control_input</strong></h4><ul>
<li>从数据包的包头中提取数据，根据不同数据类型进行操作。</li>
<li>操作函数暂存在 <strong>handler</strong> 中。</li>
<li>具体的操作函数将在后续文章中逐个介绍。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 'msg', which is 'length' bytes long, was received from the control path.</span></span><br><span class="line"><span class="comment"> * Apply it to 'chain'. */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">fwd_control_input(struct datapath *dp, <span class="keyword">const</span> struct sender *sender,</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> (*handler)(struct datapath *, <span class="keyword">const</span> struct sender *, <span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ofp_header</span> *<span class="title">oh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> min_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check encapsulated length. */</span></span><br><span class="line">    oh = (struct ofp_header *) msg;</span><br><span class="line">    <span class="keyword">if</span> (ntohs(oh-&gt;length) &gt; length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(oh-&gt;version == OFP_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Figure out how to handle it. */</span></span><br><span class="line">    <span class="keyword">switch</span> (oh-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> OFPT_BARRIER_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_barrier_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_FEATURES_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_features_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_GET_CONFIG_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_get_config_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_SET_CONFIG:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_switch_config);</span><br><span class="line">        handler = recv_set_config;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_PACKET_OUT:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_packet_out);</span><br><span class="line">        handler = recv_packet_out;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_FLOW_MOD:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_flow_mod);</span><br><span class="line">        handler = recv_flow;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_PORT_MOD:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_port_mod);</span><br><span class="line">        handler = recv_port_mod;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_STATS_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_stats_request);</span><br><span class="line">        handler = recv_stats_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_ECHO_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_echo_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_ECHO_REPLY:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_echo_reply;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_QUEUE_GET_CONFIG_REQUEST:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_header);</span><br><span class="line">        handler = recv_queue_get_config_request;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFPT_VENDOR:</span><br><span class="line">        min_size = <span class="keyword">sizeof</span>(struct ofp_vendor_header);</span><br><span class="line">        handler = recv_vendor;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        dp_send_error_msg(dp, sender, OFPET_BAD_REQUEST, OFPBRC_BAD_TYPE,</span><br><span class="line">                          msg, length);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle it. */</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; min_size)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> handler(dp, sender, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后回到非常重要的函数 <strong>send_openflow_buffer</strong> ，此函数也在之前多次看到，现在我们来看一下它的具体代码。</p>
<h4 id="send-openflow-buffer"><a href="#send-openflow-buffer" class="headerlink" title="send_openflow_buffer"></a>send_openflow_buffer</h4><ul>
<li>函数首先判断是否为控制器发送来的数据，如果是，则sender不为零，执行第一个if操作，发送回去。</li>
<li>如果不是，解析目的端口，然后用 <strong>send_openflow_buffer_to_remote</strong> 把 buffer 发送到安全信道。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">send_openflow_buffer(struct datapath *dp, struct ofpbuf *buffer,</span><br><span class="line">                     <span class="keyword">const</span> struct sender *sender)</span><br><span class="line">&#123;</span><br><span class="line">    update_openflow_length(buffer);</span><br><span class="line">    <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">        <span class="comment">/* Send back to the sender. */</span></span><br><span class="line">        <span class="keyword">return</span> send_openflow_buffer_to_remote(buffer, sender-&gt;remote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Broadcast to all remotes. */</span></span><br><span class="line">        struct remote *r, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        LIST_FOR_EACH (r, struct remote, node, &amp;dp-&gt;remotes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">                <span class="comment">//send_openflow_buffer_to_remote(ofpbuf_clone(buffer), prev);</span></span><br><span class="line">                send_openflow_buffer_to_remote(buffer, prev);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">            send_openflow_buffer_to_remote(buffer, prev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ofpbuf_delete(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="send-openflow-buffer-to-remote"><a href="#send-openflow-buffer-to-remote" class="headerlink" title="send_openflow_buffer_to_remote"></a>send_openflow_buffer_to_remote</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_openflow_buffer_to_remote(struct ofpbuf *buffer, struct remote *remote)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = rconn_send_with_limit(remote-&gt;rconn, buffer, &amp;remote-&gt;n_txq,</span><br><span class="line">                                       TXQ_LIMIT);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        VLOG_WARN_RL(&amp;rl, <span class="string">"send to %s failed: %s"</span>,</span><br><span class="line">                     rconn_get_name(remote-&gt;rconn), strerror(retval));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sends 'b' on 'rc'.  Increments '*n_queued' while the packet is in flight; it</span></span><br><span class="line"><span class="comment"> * will be decremented when it has been sent (or discarded due to</span></span><br><span class="line"><span class="comment"> * disconnection).  Returns 0 if successful, EAGAIN if '*n_queued' is already</span></span><br><span class="line"><span class="comment"> * at least as large as 'queue_limit', or ENOTCONN if 'rc' is not currently</span></span><br><span class="line"><span class="comment"> * connected.  Regardless of return value, 'b' is destroyed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because 'b' may be sent (or discarded) before this function returns, the</span></span><br><span class="line"><span class="comment"> * caller may not be able to observe any change in '*n_queued'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is no rconn_send_wait() function: an rconn has a send queue that it</span></span><br><span class="line"><span class="comment"> * takes care of sending if you call rconn_run(), which will have the side</span></span><br><span class="line"><span class="comment"> * effect of waking up poll_block(). */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">rconn_send_with_limit(struct rconn *rc, struct ofpbuf *b,</span><br><span class="line">                      <span class="keyword">int</span> *n_queued, <span class="keyword">int</span> queue_limit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    retval = *n_queued &gt;= queue_limit ? EAGAIN : rconn_send(rc, b, n_queued);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        ofpbuf_delete(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几段代码比较简单，不过多说明，总之就是通过 <strong>rconn_send</strong> 发送到安全信道中。</p>
<p>因为是主函数直接调用的函数，总体还是框架性的函数。其他功能性函数将在接下里的文章中介绍。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OpenFlow/" rel="tag"># OpenFlow</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/16/post5/" rel="next" title="Open VSwitch in OpenWrt">
                <i class="fa fa-chevron-left"></i> Open VSwitch in OpenWrt
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/24/post7/" rel="prev" title="OpenFlow1.0.0 代码解读——add port">
                OpenFlow1.0.0 代码解读——add port <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Fantin" />
          <p class="site-author-name" itemprop="name">Fantin</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/FantinYang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="yangfan.gm@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-e-mail"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yangfantin" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/y526147723/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#parse-options"><span class="nav-number">1.</span> <span class="nav-text">parse_options</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dp-new"><span class="nav-number">2.</span> <span class="nav-text">dp_new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemonize-void"><span class="nav-number">3.</span> <span class="nav-text">daemonize(void)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make-socket"><span class="nav-number">4.</span> <span class="nav-text">make_socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dp-run"><span class="nav-number">5.</span> <span class="nav-text">dp_run</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#netdev-recv"><span class="nav-number">5.1.</span> <span class="nav-text">netdev_recv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fwd-port-input"><span class="nav-number">5.2.</span> <span class="nav-text">fwd_port_input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run-flow-through-tables"><span class="nav-number">5.3.</span> <span class="nav-text">run_flow_through_tables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execute-actions"><span class="nav-number">5.4.</span> <span class="nav-text">execute_actions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-output"><span class="nav-number">5.5.</span> <span class="nav-text">do_output</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#do-output-port"><span class="nav-number">5.5.1.</span> <span class="nav-text">do_output_port</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-output-control"><span class="nav-number">5.5.2.</span> <span class="nav-text">do_output_control</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remote-run"><span class="nav-number">5.6.</span> <span class="nav-text">remote_run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fwd-control-input"><span class="nav-number">5.7.</span> <span class="nav-text">fwd_control_input</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#send-openflow-buffer"><span class="nav-number">5.8.</span> <span class="nav-text">send_openflow_buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#send-openflow-buffer-to-remote"><span class="nav-number">5.8.1.</span> <span class="nav-text">send_openflow_buffer_to_remote</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fantin</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
